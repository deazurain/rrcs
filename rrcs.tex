\documentclass{article}
\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[numbers]{natbib}
\usepackage{xcolor}
\usepackage[colorlinks,linkcolor=blue,urlcolor=blue]{hyperref}
\usepackage{mathrsfs}

\input{tikz/tikz}

% Nieuwe titel? : \title{Using Precedence Constraint Posting in Partial Order Schedules for Continuous Scheduling.}
\title{Precedence Constraint Posting in Continuous Planning; Practical Adoption of the Scheduling Problem.}
\author{M. van Gelderen  \and
    R.M. de Lange \and
    B. Gris\`el \and
    F. van Tienen}
\date{}

\pagestyle{empty}

\newcommand{\TODO}[1]{{\color{red}\textbf{TODO: #1}}}

\newcommand{\renres}[0]{R^\rho} %renewable resource
\newcommand{\conres}[0]{R^\nu} %consumable resource
\newcommand{\av}[1]{\textit{Av}(#1)} %availability
\newcommand{\dur}[1]{\textit{Dur}(#1)} %durability
\newcommand{\usage}[1]{\textit{Usage}(#1)} %usage
\newcommand{\start}[1]{\textit{Start}(#1)} %start time

%\setlength{\parindent}{0pt}
%\setlength{\parskip}{\baselineskip}

\begin{document}
\maketitle
\thispagestyle{empty}

\begin{abstract}
\TODO{abstract als laatste schrijven}
\end{abstract}

\newpage

\section{Scope and purpose}
%We bekijken precedence constraint posting als methode voor het genereren van een schema voor het continuous resource constrained project scheduling probleem. 
Scheduling is a common problem in many day-to-day applications, but represents one of the more complex problems to solve.
Scheduling is the process of creating a feasible schedule with regard to a deadline, a given set of tasks and the available resources.
In many applications several complicating factors may arise.
Scheduling can deal with some of these complicating factors using constraints.
For instance, a limited number of resources, uncertain length of task execution and deadlines.
These factors represent the more simple constraints.
More complicating factors are those that can be found in practical applications, like: break-down of resources, delays or uncertain number of tasks.
Especially in dynamic environments, which is the type of environment many practical applications need to deal with.
In this paper we will explore the resource constraint scheduling problem and explain how the theory can be used to cope with these more complicating factors in a dynamic environment.

%Het doel van de paper is om een volledige informatie bron zijn voor een 3e jaars TI student over het hierboven genoemde
The purpose of this paper is to inform fellow students on the topic of resource constraint scheduling in dynamic applications.
The paper aims to be a good source of information on the topic of resource constraint scheduling and its link to the practical applications seen in daily life.
Although some prerequisite knowledge is presumed to be common to the reader, most in-depth information aims to be complete and clear.

%Eerst geven we een intuïtieve definitie van het RCPSP. Dan volgt een formele definitie van RCPSP. 
First we will define the resource constraint scheduling problem and give a formal definition on the topic.
Resource constraint scheduling is a form of scheduling that deals with a number of constraints.
The scheduling process needs to take these constraints into account to make a feasible schedule.
Constraints can for example be precedence constraints, in this case the set of tasks requires tasks to be performed in a specific order.

%Hierna volgt een intuïtieve definitie van STNs, daarna volgt een formele definitie van STNs. 
We will then explain simple temporal networks and give the formal definition.
Simple temporal networks are a reduction of the scheduling problem into a graph representing all tasks and constraints.
Temporal networks are a simple and flexible way to represent schedules.
for example precedence constraints can be represented by an edge from one task to the other, forcing the process to execute one before the other.

%Dan kunnen we de diepte in en leggen we uit wat precedence constraint posting is.
Precedence constraint posting and partial order schedules will be explained then.
Precedence constraint posting is a way of posting new precedence constraints to an existing temporal network.
This method utilizes the flexibility of such networks and allows the schedule to take new precedence constraints into account.

%Dan maken we de transitie naar continuous planning en waarom het nodig is.
Then the obstacles due to the continuity of the dynamic environment will be discussed.
Explaining why the factors involved in the continuous nature of a real-life application impose more complications in scheduling.
Some methods to improve flexibility of schedules will be discussed, to provide with a solution to these extra complications.

%Hierna leggen we uit waarom PCP geschikt is om continuous planning mee te realiseren.
The resource constraint scheduling, partial order schedule and precedence constraint posting subjects will be combined to show that a flexible and robust schedule can be created using these theories.

\TODO{Voelt nog incompleet, ook lijkt de laatste zin van de intro nu wel haast een conclusie.}

\newpage

\section{Problem background}
\TODO{Freek}

\TODO{rewrite, more text for readers management, complete definition \& make formal, use normal R, reference, explain}

\TODO{define 'optimal'}

Different aspects of the underlying theory leading to RRCS.
 Per point explanation of the theory with references to relevant papers.
This will be the main section of the paper.

\TODO{Describe what notation conventions we will adopt.
I suggest using the notation from P. Brucker et al, European Journal of Operational Research 112 (1999). }

Sched
\subsection{Formal Definition}
The general definition for the resource constraint scheduling problem is defined by a tuple $(T, V, W, E, R)$: \cite{brucker99}

Given:
\begin{itemize}
\item a horizon $T$ that denotes the total time horizon for the problem, where $T \in \mathbb{N}$
\item a set of activities(jobs) $V = v_1 \ldots v_n$, where $v_j \in V$ is a unique identifier for an activity
\item an extended set $W = w_0, \ldots w_{n+1}$ of the activities set $V$, where $\forall v_j \in V (w_j = v_j)$ with a unique dummy beginning activity $w_0$ and a unique dummy terminating activity $w_{n+1}$
\item the durations, processing time of the activities $\dur{v_i}$, so that $\dur{v_k} \in \mathbb{N}$ denotes the duration of activity $v_k \in V$ in time periods of time horizon $T$
\item a set of constraints which needs to be satisfied $E$, such that $(v_i,v_j) \in E$ means that $v_i \in V$ precedes activity $v_j \in V$ and $v_i \neq v_j$.
\item a precedence graph of the constraints and activities $G = (V, E)$, where we assume that the graph doesn't contain a cycle, otherwise the precedence relations are inconsistent.
\item a set of available resources $R$ where each element $r_i \in R$ is a unique identifier for a resource, split in renewable resources $\renres$ and  consumable (nonrenewable) resources $\conres$ but with a possible overlap of doubly constrained resources ($r_j \in \renres \cap \conres$) \TODO{Dit lijkt me niet zo handig, stel $r_1$ is zo'n dubbele, wat is $Cap(r_1)$ dan?}
\item the availabilities of the resources $\av{r_i, t}$, so that $\av{r_k, t} \in \mathbb{N}$ denotes the availability of resource $r_k \in R$ at a time period $t \in \mathbb{N}$ in the time horizon $t < T$
\item the per period usage for an activity $v_j$ of resource $r_k$ are denoted by $\usage{v_j, r_k} \in \mathbb{N}$, such that it represents the amount of resource $r_k \in R$ used per time period in time horizon of executing activity $v_j \in V$ \TODO{Weird}
\end{itemize}

Find the feasible schedule where each activity gets executed with the available resources, the resources don't exceed their availability and all the constraints between the activities are satisfied where $\start{_j} \in \mathbb{N}$ denotes the start time in periods of the time horizon $T$ for activity $v_j \in V$ and
$S = (\start{v_1} \ldots \start{v_n})$ is a feasible schedule for the activities $V = (v_1 \ldots v_n)$.

\subsection{Prerequisites}
In this section, the general problem focused on in this paper is explained.
Projects composed of activities, resources and constraints are introduced and a unifying notation is presented.
First, some terminology is discussed followed by a problem definition.

\subsubsection{Activities}
Each project consists of a finite set of activities(also called jobs) denoted as $V = v_1 \ldots v_n$, where each element of $V$ is a unique identifier for an activity and $n \in \mathbb{N}$ is the total number of activities.
Each activity $v_i \in V$ has a duration(processing time) $\dur{v_i} \in \mathbb{N}$, the time needed to complete the activity, and a starting time $\start{v_i} \in \mathbb{N}$, the time at which the activity should be executed. The duration $\dur{v_i}$ and the starting time $\start{v_i}$ are both denoted as a time period in the time horizon $T$.

We also have an extended set of activities $W = w_0, \ldots w_{n+1}$, which extends the activity set $V$ with a unique dummy beginning activity $w_0$ and a unique dummy ending activity $w_{n+1}$. This set contains all the activities of $V \subset W$ such that $forall_{1 \leq j \leq n}(w_j = v_j)$.

\begin{figure}[h]
	\centering
	\input{tikz/activity_graph}
	\caption{Example of an activity graph with dummy activities. }
	\label{fig:activity_graph}
\end{figure}

\subsubsection{Constraints}
Apart from activities that consume resources, additional constraints can be added.
Two of these are precedence constraints and temporal constrains.
Some activities need to be executed before another activity can be executed (for example, a surface needs to be sanded before it can be painted).
These dependencies are specified by a set $E \subset V \times V$.
This means that a precedence relation between activities $v_i$ and $v_j$, where $v_j$ can be started only after $v_i$ is finished, is represented as $(v_i, v_j) \in E$. 
Figure \ref{fig:activity_graph} shows an augmented graph a visualisation of 

Temporal constraints can be used to specify a minimum and maximum time lag between two activities $i$ and $j$.
The notation used in this paper is $MinLag(v_i, v_j)$ and $MaxLag(v_i, v_j)$ respectively the minimum and the maximum time lag.
\TODO{use math func. Latex}

\subsubsection{Resources}
An activity requires a certain amount of resources to be available upon execution.
For example, changing a tire might require two workmen and one car lift.
In general, there are two kinds of resources: renewable and consumable (also named nonrenewable) resources.
With a consumable resources (such as petrol), once a part of a resource is used, it will no longer be available.
This contrasts with renewable resources, which do not deplete when used.
For renewable resources, the amount of units available of resource $r_k$ at any given time is $\av{\renres_k, t}$ (for example the number of machines in a shop).
The total amount of units available for a nonrenewable resource $k$ is noted by $\av{\conres_k, t}$.
The set of all renewable resources within a project is indicated with $\renres$ and the set of renewable resources is indicated by $\conres$. 

Activities consume a certain amount of one or more resources.
The amount that an activity $j$ consumes of a resource $k$ during a unit of time is denoted by $\usage{v_j, \renres_k}$ for a renewable resource and   $\usage{v_j, \conres_k}$ for an nonrenewable resource.

\subsubsection{Schedule}
\TODO{what is time horizon?, define RCS, two types of scheduling?, don't use completion times}
The general idea of resource scheduling is to minimize the project execution time without over-utilizing the resources or violate project constraints like the constraints discussed above.
The project itself can also have a deadline, the total amount of time units before the project needs to be completed.
A mapping of a unit of time in the model and an actual timespan in the real world can be indicated by the Time Horizon $t=1,2,3,\ldots,T$ and corresponding time intervals $[t-1,t]$.
The generated schedule may not exceed the Time Horizon $T$, when the project itself has an deadline.

\begin{figure}[h]
	\centering
	\input{tikz/time_schedule}
	\caption{\TODO{verzin caption}}
	\label{fig:time_schedule}
\end{figure}

The RCS problem schedule solution is denoted by a schedule that consists of a vector of the starting times for all the activities $S =  (\start{v_1} \ldots \start{v_n})$.
There are two types of schedules, time-feasible schedules that fulfills all time constraints denoted as $S_T$ and resource-feasible schedules that fulfills all the resource constraints denoted by $S_R$.
The conjunction of the time-feasible and the resource-feasible schedule will give you a solution for the RCS problem, this is denoted by $S = S_R \cap S_T$.
We also define the completion times for the activities in $V$, this is denoted by $C = Stop(v_1) \ldots Stop(v_n)$ where $Stop(v_j)$ for each activity $v_j$ has to be less than the Time horizon $T$, this can be denoted as following $\forall_{v_j}(v_j < T)$.

\subsection{Problem Complexity}
\TODO{Reductie naar bestaand NP-compleet probleem. Dit is de reden van het paper.}
The RCS problem belongs to the class of problems that are \emph{NP-hard}. According to the \TODO{the?} complexity theory a problem belongs to the class \emph{NP-hard} if its decision version is \emph{NP-complete} \TODO{Een probleem zit in NPC als hij NP Hard is en in NP zit, ik vind deze redenatie een beetje achterstevoren}. 
That the decision version of the RCS problem belongs to the class \emph{NP-complete} is proven and thereby is proven that the RCS problem belongs to the class \emph{NP-hard}. 
\TODO{Ik zou dit stuk vervangen door een alinea die zegt in welke paper het bewijs gegeven is voor $RCPSP \in NP-Complete$ en een intuitief bewijsje geven voor waarom dat zo is}\\
The time and space complexity of the RCS problem depends on the used algorithms and approaches used to solve the problem \TODO{Is inherent aan het problem. Het gaat om de EXACTE opplossing die NP-compleet is en bepaalde ruimte gebruikt}. 
There are currently two type of algorithms which are used in most cases, the exact algorithms and the approximation algorithms.
\TODO{Explain the time and space complexity between the two different approaches and add reference to the prove}

\subsection{Problem Extension}
\TODO{Waarom extension, wat is het nut van deze paragraaf, als je het doet, bespreek het dan goed}

\TODO{REMOVE?}

The basic PS \TODO{Wtf PS?} problem will sometimes not suffice. Several extensions to the PS problem have been made of which some will be discussed here. 

\subsubsection{Multi-mode project scheduling}
Multi-mode project scheduling is an extension to the original PS problem.
In short it takes multiple ways to perform and activity into account.
The different 'modes' in which an activity can be performed have different processing times and resource requirements for that activity.
See \citet{herroelen05} for details.
The approach to scheduling that is discussed in this paper does not account for multi-mode activities.
Research into multi-mode scheduling with PCP for continuous planning has not been done to the best of the authors' knowledge. 

\subsubsection{Stochastic processing times}
Often times it will be hard to estimate processing times for activities in practice.
There is a big chance that the actual processing time will be  different from the estimate.
In depth research has been done on stochastic processing time for project scheduling to model this deviation as has been shown in \cite{brucker99} covering several important problems \TODO{Welke problemen, welke resultaten, het zegt niks wat er staat} introduced by using a stochastic distribution for activity processing times.

\subsection{Summary}
\TODO{REMOVE / MOVE to 2.1}
\begin{tabular}{l l}
\hline
$T$ & time horizon \\
$t$ \TODO{$t_i$?} &  index of a time period in the time horizon $T = (t_1 \ldots t_n)$\\
$V$ & set of activities $V = (v_1 \ldots v_n)$ \\
$n$ & number of original activities \\
$E$ & set of constraints \\
$\renres$ & consumable resources \\
$\conres$ & renewable resources \\
$\dur{v_i}$ & the duration of activity $v_i$ \TODO{Ik heb tot nu toe de term "processing time" aangehouden, welke doen we?}\\
$\av{r_i}$ & the availability of resource $r_i$ \\
$\usage{v_j, r_k}$ & the per period usage for activity $v_j$ of resource $r_k$ \\
$\start{v_i}$ & the start time of activity $v_i$ \\
$S$ & a schedule consisting of st
art times for the activities $S = (\start{v_1}) \ldots \start{v_n})$ \\
$C$ & a vector of end times for the activities $C = (Stop(v_1) \ldots Stop(v_n))$ \\
\hline
\end{tabular}

\newpage

\section{Schedule construction using PCP}
\TODO{Bastiaan}

\TODO{Structuur: Waarom PCP? Er is een probleem => NP-compleet. Dus vorm van benadering. Oberveer het volgende: als we ons puur beperken tot het tijdsaspect danr educeert het naar STN probleem wat op te lossen is in poly-time. Kunnen we het probleem niet splitsen zodat we resource deel apart nemenv antijdsdeel? We kijken naar resourceprofiel en voegen constraints toe. We beginnen met STN verhaal en daarna bespreken we hoe we constraints moeten toevoege. Twee methoden: Conflict Free en ESTA verhaal. Conflict Free is feasable voor alle starttimes en ESTA alleen voor 1 starttime. Chaining => ESTA oplossing ombouwen tot een POS.}

Since the RCPS problem belongs to the class of \emph{NP-complete} problems, no algorithm capable of constructing an optimal solution in $O(n^k)$ is known (unless of course, $P=NP$). In order to devise a solution using polynomial time, an approximation algorithm needs the be used. In this section, the approach of Precedence Constraint Posting (PCP) will be discussed.

\subsection{Introduction}
When regarding the RCPS problem, the problem has got both a time-related as well as a resource-related aspect. 
The time-related aspect focusses on scheduling the activities with respect to the given temporal constraints. 
As will be discussed below, this time-aspect of the problem can be reduced to a \emph{Simple Temporal Problem} (STP) \TODO{Refer to paper} which can be solved in $O(n^3)$ time. 
The result of this STP is a schedule or a set of schedules for which needs to be verified if the resource constraints are met. 
If there are any resource violations, \emph{Precedence Constraint Posting} (PCP) will offer a method of adding constraints to the STP in such a way that forces the resource requirements to be met in the generated schedule. 

The two aspects of this problem are regarded as two different layers, the \emph{Time Layer} and the \emph{Resource Layer}.
The Time Layer will first be discussed along with the reduction to the aforementioned STP. 
This STP will then be used to explain the relevance of the Resource Layer.

\subsection{Time Layer}
The temporal aspect of the problems deals with activity durations and precedence constraints.
These relations can be represented as a graph $G=(V,E)$ as defined in section \TODO{Reference near definition}. 
This so-called \emph{precedence graph} can be reduced to a \emph{Simple Temporal Network} (STN), which forms the basis for our STP.

\subsubsection{Simple Temporal Networks}
An STN is used to represent the temporal aspect of the RCSP and forms the basis for the STP.
An STN consists of a set $P$ of so-called \emph{time points} with associated time windows.
Relations between each pair of time points can be specified.
In an STN with uncertainty, the goal is to provide each time point $t_i$ with a lower and an upper bound such that, if a value for each $t_i$ is chosen in that interval, all the relations are satisfied.

Relations between time points can be added in the following way:
\begin{itemize}
\item $t_i \xrightarrow{[d_{ij},D_{ij}]} t_j$ called a \emph{free constraint}, meaning that the time $\delta$ between the two time points $t_i$ and $t_j$ is allowed to be scheduled within the range of $[d_{ij},D_{ij}]$.
\end{itemize}

\subsubsection{Reduction to STN}
\begin{enumerate}
\item Let S be an empty graph
\item For each activity $v_i \in V$, add two nodes (time points) $s_i$ and $e_i$ to S
\item Connect each pair of points $s_i$ and $e_i$ with a free constraint with bounds $[\dur{v_i}, \dur{v_i}]$
\item For each precedence constraint $(v_i, v_j) \in E$, add a free constraint with bounds $[0, \infty]$
\end{enumerate}

The constraint introduced in step $3$ forces the duration of the activity to be exactly $\dur{v_i}$. The constraints added in step $4$ can have any, non-negative value which enforces the activities to take place some time after each other: a precedence constraint.

\subsubsection{Relations Temporal Constraints}
In the models used to simulate the problem at hand, it is convenient to express all constraints as temporal constraints.
A precedence constraint can be modeled as a temporal constraint with a minimum lag of $0$, and a maximum lag of $\infty$.

\subsubsection{Reduction to Temporal Constraints}
The temporal aspect of the problem can be modeled using \emph{time points}, \emph{free constraints} and \emph{contingent constraints} so as to form an STN \TODO{STNU?, de Uncertainty komt van die contigent constraints toch?} in the following way:
\begin{enumerate}
\item For each activity $v_i$, introduce two time points $s_i$ and $e_i$;
\item Add a contingent constraint $s_i \xrightarrow{[d_{ij}:D_{ij}]} e_i$ for each activity; \TODO{Zitten de $i$ en de $j$ hier wel goed?}
\item Add a free constraint $s_i \xrightarrow{[d_{ij},D_{ij}]} e_i$ for each temporal constraint in the problem definition.
\end{enumerate}

\TODO{insert hip plaatje van een STNU hier}

As defined above, each activity is represented by two time points.
The contingent constraint connecting the two time points represents the duration of the activity.
The exact processing time of the activity is not yet known at this stage, only a worst-case and a best-case processing time are given.
These best-case and worst-case processing times are used respectively as lower and upper bounds for the contingent constraint.
The schedule needs to be generated in such a way that for each possible value for all of the contingent constraints (all possible combinations of processing times), the free constraints are met.

Using a technique called \emph{constraint propagation} \cite{policella07}, it is possible to bound the domains of each time point $t_i$ such that $t_i \in [lb_i, ub_i]$, in which $lb_i$ represents the lower bound and $ub_i$ represents the upper bound of the time domain for the time point $t_i$, in such a way that all relations are satisfied regardless of which duration the activities have.
It has been proven that it is possible to find such bounds for $n$ constraints in $O(n^3)$ time.
Note that the resulting STNU represents a set of schedules rather then one schedule in particular, because the exact execution times are not known yet.
Since a solution assigns values (instead of bounds) to each time point, in order to obtain a solution, a value needs to be given to each time point $t_i$.
One could, for example, take the lower bound of each time point and use that as the value for each time point.
\TODO{... to create an actual schedule instance?}

\subsection{Resource Layer}
\TODO{Verhaal van Ciesta}
\subsubsection{Resource leveling}
\subsubsection{Minimum Conflict Sets}

\subsection{Precedence Constraint Posting}
\TODO{Explain how the two layers can be brought together}
\subsubsection{Introduction}
In the classical RCPS problem described in the previous section, the input parameters of the problem, such as processing times of activities, need to be known before generating the schedule.
The solution of this problem is a fixed schedule which can then be employed in practice.
However, this off-line generation of the schedule does not offer the amount of flexibility that is often desired in practical problems.
For example, the processing time of the activities might not be precisely known beforehand and only best-case and a worst-case times can be given.
A schedule that is able to react to uncertainties and can be updated once more and more parameters become known is desired.
Using Precedence Constraint Posting (PCP), the solution of the problem is a flexible augmented schedule that can be generated using an estimate of the input parameters and can then be updated in real-time (also called on-line) to adapt to the actual values.
\TODO{Complex, long, this/that sentence :p}

\subsubsection{Scheduling Policy}
\subsubsection{Partial Ordering Schedules \TODO{Order?}}

\subsubsection{Problem Extension}
Instead of assuming each activity to have a fixed processing time, each activity is linked to a worst-case or lower bound ($p_{j} \in \mathbb{N}$) and a best-case or upper bound ($P_{j} \in \mathbb{N}$) processing time.
Whereas the classical solution of the RCPS problem was given in the form of one schedule, the result of PCP is an augmented precedence graph that defines a set of possible schedules.
This graph can be used to devise a starting time for activity $a_i$ in real-time, based on the execution history so far.
The graph needs to be constructed in such a way that 
\TODO{I don't think this paragraph is in line with the current document structure}

\newpage

\section{Continuous scheduling}

Resource constraint scheduling algorithms focus on solving a given set of tasks, time and resource constraints in a feasible schedule.
These solutions are effective on complex, closed sets of tasks, but the created schedules are not adaptive when the resources or set change during execution.
In many practical environments of where scheduling is performed, flexibility or robustness of the schedule is important, whilst changes occur regularly.
Either resources can be delayed, become unavailable or new tasks can be added to the set, all during execution.
In these applications the set of resources and tasks is not closed, but changes constantly.
This requires the schedule to be changed or updated during execution of the schedule.
Here we will take a deeper look at how to make resource constraint scheduling more practically applicable in continuously changing environments.

We will first discuss schedule repair solutions, which reschedule the solution when problems occur that disrupt the execution.
These repair solutions provide a way to repair a schedule when certain changes occur, for example due to delays in the process.
Then we will review flexible schedules and a special example of these flexible schedules, namely partial order schedules.
The flexible schedule contains several feasible schedules, enabling it to be adjusted to changes without the need for complete rescheduling.
Partial order schedules have an extra property, where the original output schedule can be used as input schedule for recalculating the solution.
Finally we will take a look at how precedence constraint posting can be used in combination with partial order schedules, to provide with flexible resource constraint schedules.

\subsection{Schedule repair}
One solution to handle continuous changes to the problem set is schedule repair.
This reactive solution reschedules the solution as soon as problems or conflicts are detected.
Using this type of repair requires the execution of the schedule to be paused, a new schedule to be calculated based on the changed problem set and the execution to be restarted with the new schedule.
Pausing and repairing a schedule is a very time consuming solution, especially in environments where many changes may occur.
To maximize effectiveness, the repair needs to be fast and allow the execution to continue with the minimum delay.
Different solutions exist, which mostly favor either a quick repair or a more complete rescheduling.
\cite{policella07}
Complete rescheduling often provides with a better schedule, which has a shorter execution time or uses resources more efficient.
Whilst the quick repair does not do this, but delivers a new schedule in less time.

Schedule repair gives the ability to build a schedule although there are unknown factors in the environment, but requires the execution to be paused and repaired when problems occur.

\subsection{Flexible schedules}
Another solution is a more proactive approach, using flexible schedules.
Flexible schedules are schedules which retain flexibility by coping with several changes without the need for rescheduling.
These solutions present a form of redundancy, in time and/or resources.
This redundancy represents multiple feasible schedules within one solution.
Therefore allowing the process to select the execution which most resembles the actual environment.
For flexible schedules it is required to know all sorts of changes that may occur in advance, in order to construct the correct flexible schedule.
This requirement poses a big strain on the scheduling on forehand, because several, possibly unknown, factors need to be taken into account.
If an unexpected change should occur, the schedule will most likely not be capable of handling that change.
In this case complete rescheduling is necessary.

Flexible scheduling provide a way to use the original flexible schedule and adopt it to the environment, but can only cope with known changes and problems.

\subsection{Partial order schedules}
Partial order schedules are flexible schedules which take the flexibility a step further.
In partial order schedules, as defined in \citet{policella07}, each activity retains a set of feasible start times.
They are represented by a temporal network, this network represents the different feasible schedules, similar to other flexible schedules.
In all flexible schedules there is a possibility that the changes that occur are too large to adapt the schedule and rescheduling is required.
This is where the main advantage of partial partial order schedules is, the original schedule can be used as input for the rescheduling algorithm.
By reusing the previous costly time can be preserved in building a new schedule.

The rescheduling algorithm uses a temporal network as input, which is similar to the output itself generates.
Because the original schedule is modified and reused, partial order schedules make the complete rescheduling less intensive.
This property makes partial order schedules not only flexible and robust, but also quick to repair when bigger changes occur.
Therefore partial order scheduling is especially suitable for applications in a dynamic environment.

\subsection{Precedence constraint posting in partial order schedules}
Precedence constraint posting, as discussed in the previous chapter, is a technique for finding feasible schedules by adding new precedence constraints to a temporal network.
This posting of new precedence constraints can be used to update the temporal network of a partial order schedule.
In this manner several large adjustments can be posted to a schedule, which can then be easily rescheduled.
Precedence constraint posting in combination with partial order schedules give a very robust and flexible solution to the scheduling of tasks in a dynamic environment.


\newpage

\section{Conclusion}
\TODO{The overall conclusion.}

\newpage
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}








