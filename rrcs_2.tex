\documentclass{article}
\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[numbers]{natbib}
\usepackage{xcolor}
\usepackage[colorlinks,linkcolor=blue,urlcolor=blue,citecolor=blue]{hyperref}
\usepackage{mathrsfs}
\usepackage{comment}

\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{caption}% http://ctan.org/pkg/caption
%\captionsetup[table]{justification=raggedright, singlelinecheck=off}
\usepackage{amsthm}
\usepackage{nameref}
\usepackage{wrapfig}
\theoremstyle{definition}
\usepackage{pgf}
\usepackage{algorithm2e}
\providecommand{\SetAlgoLined}{\SetLine}
\providecommand{\DontPrintSemicolon}{\dontprintsemicolon}
\newcommand{\inputtikz}[1]{\input{tikz/#1}}

\inputtikz{preamble}

\title{An Approach to Resource Constrained Project Scheduling}
\author{M. van Gelderen  \and
    R.M. de Lange \and
    B. Gris\`el \and
    F. van Tienen}
\date{}

\pagestyle{empty}


% long footnote section fixes
\dimen\footins=40\baselineskip\relax
\raggedbottom
\addtolength{\topskip}{0pt plus 10pt}
\interfootnotelinepenalty=10000

\newcommand{\TODO}[1]{{\color{red}\textbf{TODO: #1}}}
\newtheorem{example}{Example}[section]

\newcommand{\res}[0]{\ensuremath{R}} %resources
\newcommand{\av}[2]{\ensuremath{av(r_{#1}, t_{#2})}} %availability of resource #1 at time #2
\newcommand{\capa}[1]{\ensuremath{cap(r_{#1})}} %capacity
\newcommand{\dur}[1]{\ensuremath{dur(v_{#1})}} %durability
\newcommand{\usage}[2]{\ensuremath{usage(v_{#1}, r_{#2})}} %usage of resource #2 by activity #1
\newcommand{\start}[1]{\ensuremath{start(v_{#1})}} %start time
\newcommand{\makespan}[1]{\ensuremath{C_{max}(#1)}} %makespan

\newcommand{\mindelay}[2]{\ensuremath{delay_{min}(t_{#1}, t_{#2})}} %minimum delay
\newcommand{\maxdelay}[2]{\ensuremath{delay_{max}(t_{#1}, t_{#2})}} %maximum delay
\newcommand{\weight}[2]{\ensuremath{weight(t_{#1}, t_{#2})}} %weight

\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}

\begin{document}
\maketitle
\thispagestyle{empty}

\begin{abstract}
In many everyday applications there are tasks to schedule.
From choosing to go to the bank or the shopping center first to selecting which train to repair when in a maintenance depot.
These small and large scheduling problems can be related to the resource constrained project scheduling problem.
This problem represents one of the more complex problems known in computer science, an NP-hard problem.
Therefore the use of scheduling algorithms is an intensive and time consuming process.
For the numerous everyday applications this process needs to be done in a more timely manner.
In this paper we will explain how precedence constraint posting can be used to represent the resource constraint problem with an simple temporal problem.
Because the simple temporal problem is solvable in polynomial time, this gives a quicker solution to the original problem.
Although the solution is generated more quickly than in the original form, the approximation does mostly not give an optimal solution.
Therefore this approach to resource constrained project scheduling is an effective solution for everyday applications, it is not a method for generating the most optimal schedule possible.
\end{abstract}


\newpage


\section{Introduction}

% Algemene introductie op scheduling
Every day, there are several tasks we have to complete, like going for groceries, visiting the bank and going to work.
And every day we make a schedule in what order to perform these tasks.
Finding a suitable schedule to do all of these activities may sometimes be trivial. 
In other cases however, making a schedule may not be as simple, for instance when some activities have to be done at the same time, or you need a car which is not available at that moment. 
If you have ever found yourself working on a project you will know that it is not always easy to plan all the activities, for instance when there are multiple people involved. 
The problem of finding a suitable schedule is often encountered in our modern lives.
Larger versions of scheduling problems are often found in business applications where immense sets of tasks have to be scheduled in, ideally, the best way possible.

%	Praktijkvoorbeeld 1: Trein repareer schema's
An example of a real life scheduling problem is that of train maintenance scheduling. 
The trains that are utilized by the major Dutch railway company need to undergo regular maintenance. 
This happens in special service bays who might be specialized in maintaining specific parts of a train. 
There are for example service bays that specialize in treating the electrical wiring or in maintaining the wheels.
In scheduling the maintenance of these trains, there are several constraints that need to be satisfied and objectives set by the planner before a schedule can be considered to be `good'. 
It is for example desirable to minimize the time that a train is in maintenance to maximize the use of the trains, this is an objective set by the planner.
But there is a legal obligation to perform maintenance regularly to ensure passenger safety, this is a constraints. 
These demands on the schedule makes finding a suitable schedule in reasonable time a complex task. 

% Praktijkvoorbeeld 2: Airport
Another practical problem is the scheduling of plane flights and servicing them in between. 
For airport scheduling we have to think about refueling, baggage handling, boarding and disembarking among many other activities.
The order in which these activities have to be performed are important as well as the limited availability of for example plane refueling teams and other staff. 
The airlines wish to utilize the aircrafts at maximum capacity, but must keep in mind the safety and regulations that limit their possibilities to do so.

% Name of the scheduling problem: 
This paper deals with a type of scheduling problem called the \emph{Resource Constrained Project Scheduling Problem} (RCPSP). 
This model is flexible enough to give an reasonably accurate representation of for example the train and airport scheduling problems. 
What we mean by reasonably accurate is that a solution to the model can be used as a schedule in practice, but not every scheduling problem can be translated to a RCPSP.
Extensions to the RCPSP can be made to better accommodate for a specific problem but a detailed description of known extensions is beyond the scope of this paper.

%	Structuur van de paper
\subsection{Organization}
A detailed explanation of the RCPSP is given in chapter \ref{text:RCPSP}. 
Chapter \ref{text:RCPSP} we will dive in to the resource constraint scheduling problem.
Here the different aspects of the resource constraint project scheduling problem will be discussed.
An example of a scheduling problem will be given, along with an intuitive description and formal definitions of the problem.
We will also look into the complexity \ref{text:complex} of the problem, showing why an approximation is needed for practical applications.

The following chapter, \ref{text:schedule} \emph{Schedule Construction}, will deal with the approximation of the solution.
For the approximation, simple temporal networks \ref{text:STN} will be used, which provide with a simpler way of representing a schedule.
The simple temporal networks will be explained using the example from the previous chapter and again giving an intuitive and formal definition.
When a more dynamic way of adjusting the schedule is required, precedence constraint posting \ref{text:PCP} is introduced to the simple temporal networks.
Precedence constraint posting is a technique which allows for changes to a temporal network by introducing new precedence constraints.
The workings of precedence constraint posting will also be explained using the example and giving an intuitive and formal definition.

Combining these two methods gives us a flexible way of approximating a resource constraint project scheduling problem.
Concluding we will show that this combination provides us with a solution capable of scheduling complex problems in continuous environments.
This gives us a robust and effective solution for scheduling in many practical applications.

\newpage

\section{RCPSP}
\label{text:RCPSP}

%	What are scheduling problems?
This chapter provides an overview of what the RCPSP is along with an example that we use to demonstrate ideas and concepts throughout the entire paper. 
In Section \ref{text:RCPSP_description} we introduce the components that are used in describing the RCPSP. 
After we are familiar with the components we can describe our running example which is done in Section \ref{text:running_example_description}. 
The notation that we will use to denote the components of the RCPSP is introduced using the running example in \ref{text:RCPSP_notation}. 
In Section \ref{text:running_example_definition} we give a short description of the running example using the notation that has been explained in the previous Section. 
This is followed by Section \ref{text:RCPSP_definition} where a short formal definition of the RCPSP is given. 
This chapter concludes with a note on the complexity of the RCPSP. 

\subsection{Problem Introduction}
\label{text:RCPSP_description}
The practical examples given in the introduction provides an idea about the uses of resource constrained project scheduling, but what is it exactly?
The terminology to describe resource constrained project scheduling and how its problem is constructed is introduced in this section.

% activities
Every scheduling problem has a set of \emph{activities} of some sort and this is no different for the RCPSP. 
These activities may also be referred to as jobs or tasks but we will adhere to describing them as activities. 
Examples of activities are ``sanding the surface of a fence'' or ``painting a fence''. 
The activities of a project are specified in the RCPSP instance of that project along with the \emph{duration} of each activity. 
% duration
The duration of an activity is usually an estimate of the actual time required to complete the activity because the exact duration is not known beforehand. 
A painter might visit the fence to estimate how long it will take him to sand the fence and how much time he will have to spend painting it. 

% precedence relation
Some activities are dependent of each other. 
Looking back to the painting project activities, the fence has to be sanded before it can be properly painted. 
This precedence relation between the activities ``sand fence'' and ``paint fence'' is also part of the project description and is described as a \emph{precedence constraint}. 

% resources
Precedence constraints are just one of the two types of constraints that can be used in the basic RCPSP. 
The other constraint type is concerned with \emph{resources}. 
We extend the painting project to show what a resource is in the RCPSP. 
Lets say that there are two people working on the painting project. 
However, there is also more work; there is a door that has to be painted as well. 
The problem is that there is only one painting brush available. The painting brush is a resource. 
The reason for explicitly defining this resource is because there is limited number of it; there is only one painting brush available. 
We describe this limit as the capacity of the resource. 
The activities ``paint fence'' and ``paint door'' cannot be executed simultaneously because they both depend on the availability of the painting brush. 
In other words, doing these activities requires two painting brushes which exceeds the resource capacity, thus violating the \emph{resource constraint}. 

% schedule
The activities are the elements that need to be scheduled. 
A \emph{schedule} is nothing more than a lists of the starting times for each activity. 
Such an assignment of starting times can be \emph{feasible} or \emph{infeasible}. 
A schedule is called feasible when it satisfies the precedence constraints as well as the resource constraints. 

% deadline
In some practical applications it is useful to have a deadline for the entire schedule. 
In the case of the painting project, we might be doing the repainting of a house that is going to be sold. 
This means that all the activities in the project must be completed before the date on which the house is going for sale. 
The project manager might want to consider buying an extra painting brush if we fail to find a schedule that completes before the deadline passes. 
Even if a project does not have a real deadline, we can still express that by saying that the project has a deadline of infinitely far in the future. 

% time mapping
It is useful to define the duration and start times of activities in terms of periods. 
In for example the painting project, it makes sense to express the duration of the activities in hours. 
A period in the painting project would then equal one hour. 
In another project a period might equal one day or one minute, it all depends on the context of the project. 
These time periods provide a simple way of dealing with arbitrary time steps. 
The periods can be linearly layed out on a so called time horizon. 
The length of this time horizon is equal to the deadline of the project. 
This means that a schedule can be planned over an unlimited amount of periods if the deadline is infinitely far in the future. 

The notation\footnote{The notation for the RCPSP terminology is presented in a different order than the explanation in this section on purpose. The authors felt that starting with the more easy to grasp concepts such as activities and resources felt more natural here.
The notation section however benefits from a different order. } of the concepts explained here is given in Section \ref{text:RCPSP_notation}.
But before we go to the notation, we will illustrate the RCPSP with an example that will be used throughout the paper. 

\subsection{Running example}
\label{text:running_example_description}
This section gives a description of an example RCPSP instance that we will use throughout the paper. 
We will often refer to this example as the \emph{running example}. 

The running example is based on a project that is executed by a house renovation company. 
The project is simplified for our purposes by making it smaller while maintaining the complexity of an actual RCPSP problem. 
The project is concerned with repainting several parts of an old house. 
The parts that need to be repainted are a door, a fence and a wall. 
The door and the fence are made of wood. 
This means that the surfaces of the door and the fence need to be sanded before they can be painted. 
The wall can be repainted without sanding it. 
When the job is finished all of the tools have to be cleaned. 
This gives us six activities: sanding the the door, sanding the fence,  painting the door, painting the fence, painting the wall and cleaning up. 
We also have the following precedence constraints: sanding the door before painting the door, sanding the fence before painting the fence and doing all the painting and sanding activities before the cleanup activity. 

\begin{wraptable}{r}{.34\textwidth}
	\centering
	\vspace{-.6em}
	\begin{tabular}{l|l}
		{Activity} & {Duration} \\
		\hline
		sanding the door & 3 hours\\
		sanding the fence & 2 hours\\
		painting the door & 2 hours\\
		painting the fence & 1 hour\\
		painting the wall & 5 hours\\
		cleaning up & 1 hour\\
		\hline
	\end{tabular}
	\vspace{-.3em}
	\caption{Activity durations}
	\label{table:activity_durations}
	\vspace{-.6em}
\end{wraptable}

It is to be expected that the time required to complete an activity is not the same for all the activities in the project. 
Each activity can have a different estimated \emph{duration}.
The painting project manager specifies the duration for each of the activities in whole hours, because the exact duration is not so critical. 
The activity durations for the painting project are summarized in Table \ref{table:activity_durations}. 
The manager would like to plan the activities on whole hours. 
This means that the periods in the time horizon have a length of one hour. 
To save on traveling costs, the manager wants to try and find a schedule where the painters have to visit the old house only once. 
The maximum time that the painters can spend on a project in a single day is 10 hours. 
This means that the project has a real deadline and that it is set to 10 periods. 

Normally there are enough tools available for everyone to work with.
Unfortunately, the crew\footnote{The crew could be seen as a resource by itself. We will however assume that there are enough worksmen available so that we do not have to take them in account as a limited resource. } has a very limited amount of tools this time around.
There are two painting brushes available and only one sanding machine. 
This makes it impossible to sand more than one surface at the same time and to paint more than two surfaces at the same time.
The painting brushes and the sanding machines are the resources of this project. 

We will assume that the painters greatly appreciate their privacy and prefer to work alone on an activity. This means that the sanding and painting activities will each require at most one sanding machine or painting brush at a time. 
The cleanup activity however requires all of the tools at once. 

The manager of the painting project wants to find a schedule that is feasible. 
In other words, the manager wants a schedule that does not violate any of the precedence constraints, fits within the time horizon and at no point in time exceeds any of the the resource capacities. 

\subsection{Notation}
\label{text:RCPSP_notation}
The notation for the RCPSP used in this paper is introduced in this section. We explain the notation by means of the running example and several illustrations. The notation itself is heavily based on work by \citet{brucker99}. 

The \emph{time horizon} is a mapping of real-world time to model-time. It is indicated by the so called time horizon $T \in \mathbb{N}$.
The periods within the time horizon $t=1,2,3,\ldots,T$ are also notated as $t_j$ which means the $j$-th time period in the time horizon $T$. 
The time period $t_j$ corresponds to the time interval $(t-1,t]$. 
The real-time length of a period can be arbitrarily chosen and changed without affecting the underlying scheduling problem instance. 

\begin{figure}[ht]
	\centering
	\inputtikz{activity_graph}
	\caption{Activity graph for the running example.}
	\label{fig:activity_graph}
\end{figure}


All the activities of a project are notated as $V = \{v_1, \ldots, v_n\}$.
This is a set that contains all the activities where the total amount of activities is $n = |V|$ and each element $v_i \in V$ from this set represents the i-th activity of the project.
In the running example we have six activities. Figure \ref{usage} shows a complete assignment of indexes to the activities. 

The activity set for the running example is notated as $V = \{v_1, \ldots, v_6\}$. 
These activities are represented in Figure \ref{fig:activity_graph} as blocks.

The duration for each activity $v_i \in V$ is specified by a function $\dur{i} \in \mathbb{N}$.
In the running example the activities have the following duration: $\dur{1} = 3, \dur{2} = 2, \dur{3} = 2, \dur{4} = 1, \dur{5} = 5, \dur{6} = 1$ as can also be seen in Figure \ref{usage}. 
The duration of each activity in the running example is represented by the length of the block in Figure \ref{fig:activity_graph}.

The \emph{extended activity set} is specified by $W = V \cup \{v_0, v_{n+1}\}$.
Which consists of the activity set $V$ with two additional \emph{dummy activities}: a unique dummy beginning activity $v_0$ and a unique dummy ending activity $v_{n+1}$. 
These dummy activities have a duration of $0$ periods. 
They can be of use for example in algorithms as starting values. 
For the running example we have a set $W = \{v_0, \ldots v_7\}$.
Figure \ref{fig:activity_graph} shows $W$ for the running example.
In the figure $v_0$ and $v_7$ are filled with a shade of gray to emphasize that their width does not reflect their duration. 

The precedence constraints are specified by a minimal set $E \subseteq V \times V$. 
This means that a precedence relation between two activities $v_i$ and $v_j$ is notated as an ordered pair $(v_i, v_j)$ where $v_j$ can be started only after $v_i$ is finished. 
These pairs $(v_i, v_j)$ are the elements of $E$.
Note that the set $E$ is the minimal set required to define the ordering of all the activities. 
The running example has several precedence constraints between the activities, which make up the following set $\{(v_1, v_3), (v_2, v_4), (v_3, v_6), (v_4, v_6), (v_5, v_6)\}$.
Precedence constraints for the dummy activities $v_0$ and $v_7$ are added to ensure that the starting activity starts before every other activity and that every activity is completed before the ending activity.
Figure \ref{fig:activity_graph} shows the precedence constraints for the running example including dummy activities, represented as arrows between the nodes.
The precedence constraints for the dummy activities are limited to constraints from $v_0$ to $v_1$, $v_2$ and $v_5$ and from $v_6$ to $v_7$. 
To see why $E$ is reffered to as a minimum set, look at the missing constraint $(v_0, v_3)$ in Figure \ref{fig:activity_graph}. 
This constraint is not required because it can be transitively deduced.

The graph from Figure \ref{fig:activity_graph} is called a \emph{constraint graph}. It is specified by a directed graph $G = (V, E)$.
The graph consists of a set of activities $V$, which are represented as nodes, and a set of precedence constraints $E$, which are represented as directed edges the nodes.

\begin{figure}[h]
	\centering
	\inputtikz{usage}
	\caption{Activities, resources and the relation between them for the running example.}
	\label{fig:resource_graph}
\end{figure}

\emph{Resources} are specified by a set $R = \{r_1, \ldots, r_m\}$.
The total amount of resources is $m \in \mathbb{N}$ and each resource is represented by a unique identifier. %identifier??
In the running example we have two resources ($m = 2$): the sanding machine $r_1$ and the painting brushes $r_2$.
Which gives us the total set of resources $R = \{r_1, r_2\}$.

The \emph{capacity} of each resource $r_i \in R$ is specified by a function $\capa{i} \in \mathbb{N}$.
For the running example the capacity for the resources are: $\capa{1} = 1, \capa{1} = 2$, because we have one sanding machine and two painting brushes.
These capacities of the running example are shown in Figure \ref{fig:resource_graph}.

The \emph{usage} of an activity $v_i \in V$ consumes of a resource $r_j \in \res$ during its execution is specified by the function $\usage{i}{j} \in \mathbb{N}$.
The running example has the following usages: $\usage{1}{2} = 1, \usage{2}{2} = 1, \usage{3}{1} = 1, \usage{4}{1} = 1, \usage{5}{1} = 1, \usage{6}{1} = 2$.
In Figure \ref{fig:resource_graph} the usage of the running example is expressed as a relation between activities and resources, where the number between the relation is the amount of usage.

\begin{figure}[h]
	\centering
	\inputtikz{schedule_feasible}
	\caption{A feasible schedule for the running example. }
	\label{fig:time_feasible_schedule}
\end{figure}

A \emph{schedule} is specified by a set $S = \{\start{1}, \ldots, \start{n}\}$.
In this schedule each activity $v_i \in V$ has a starting time $\start{i}$ which is defined in the schedule $S$.
When we create a schedule for the running and we also take in account the precedence constraints, you could get the following schedule:
(0, 0, 3, 2, 0, 6). 
This schedule is called a \emph{time feasible schedule} and is represented in Figure \ref{fig:time_feasible_schedule}. 

The \emph{makespan} of a schedule $S$ is the number of periods required to finish the project using the schedule $S$. The makespan is notated as $\makespan{S} \in T$.
In Figure \ref{fig:time_feasible_schedule} we have a time feasible schedule, where the makespan is optimized to a minimum and all the precedence constraints hold.

\begin{figure}[h]
	\centering
	\inputtikz{schedule_feasible_profile}
	\caption{Overview of the resource usage by activities over time. }
	\label{fig:feasible_schedule}
\end{figure}

A \emph{feasible schedule} is denoted as $S_f$ and takes in account both the precedence and the resource constraints.
The schedule from Figure \ref{fig:time_feasible_schedule} is also represented in Figure \ref{fig:feasible_schedule} as Schedule A.
In Figure \ref{fig:feasible_schedule} one can see the capacity of the resources, denoted by the dotted line, and the usage of resources at a certain time, denoted by the height of the activities in the graph.
This makes it easy to see that the capacity of $r_1$ (the sanding machine) is exceeded from $t_0$ till $t_2$, because they can't sand the fence and the door at the same time.
This means that Schedule A is a time feasible schedule, but not a feasible schedule.
An example of a feasible schedule is shown in Figure \ref{fig:feasible_schedule}, Schedule B.

\TODO{av(...) verwijderen uit deze tekst!}
The \emph{availability} of an activity $v_i \in V$ at a time $t_j \in T$ is specified by a function $\av{i}{j} \in \mathbb{N}$.
For example if you only paint one object in the running example at $t_1$, the availability of $r_2$ is $\av{2}{1} = 1$ because we have two painting brushes and only one is used.
In Figure \ref{fig:feasible_schedule} the availability of a resource can be deduced trough capacity, the dotted line, and the sum of the usage on a given time, the height of the activities in the graph. 

\subsection{Formal definition of the running example}
\label{text:running_example_definition}

Here we will specify Example \ref{exmp:running} using the formal definition from Section \ref{text:RCPSP_notation}.
\begin{example}
\label{exmp:running}
$V = \{v_1, \ldots, v_6\}$\\
$E = \{(v_1, v_3), (v_2, v_4), (v_3, v_6), (v_4, v_6), (v_5, v_6)\}$\\
$R = \{r_1, r_2\}$\\
$\dur{1} = 3, \dur{2} = 2, \dur{3} = 2, \dur{4} = 1, \dur{5} = 5, \dur{6} = 1$\\
$\usage{1}{2} = 1, \usage{2}{2} = 1, \usage{3}{1} = 1, \usage{4}{1} = 1, \usage{5}{1} = 1, \usage{6}{1} = 2$\\
$\capa{1} = 2, \capa{2} = 1$
\end{example}


\subsection{RCPSP formal definition}
\label{text:RCPSP_definition}

\begin{definition}
Given:
A set of activities $V = v_1, \ldots, v_n$, a set of resources $R = \{r_1, \ldots, r_m\}$ and a set of precedence constraints $E \subseteq  \{(v_i, v_j) | v_i \in V, v_j \in V, v_i \neq v_j\}$.
Where each activity $v_i \in V$ has a duration $\dur{i} \in \mathbb{N}$ and each resource $r_j \in R$ has a capacity $\capa{j} \in \mathbb{N}$. 
And each activity $v_i \in V$ can use the capacity of a resource $r_j \in R$ with usage $\usage{i}{j} \in \mathbb{N}$.

Find:
A feasible schedule $S_f = \{s_1, \ldots s_n\}$, consisting of starting times for the activities in $V$.
Where each precedence constraint in $E$ holds, denoted by $\forall (v_i, v_j) \in E$ $(\start{i} + \dur{i} \leq \start{j})$.
And no resource exceeds its capacity in usage at any time in the schedule, denoted by $\forall r_i \in R, t_j \in T (0 \leq \av{i}{j})$.
\end{definition}


\subsection{Complexity of the RCPSP}
\label{text:complex}
it has been proven that RCPSP belongs to the class of \emph{NP-complete} problems.
This means that increased processing power does not notably speed up the generation of solutions to the problem.
An exact algorithm for the RCPSP problem in polynomial time is not known.

Another approach in finding solutions for the RCPSP is an heuristic algorithm.
An heuristic algorithm can find solutions for the RCPSP problem and does notably speed up the generation of solutions to the problem when the processing power increases.
To achieve this heuristic algorithm trade-offs need to be made in completeness, optimality, accuracy, and/or precision for speed.
This means for example that an heuristic algorithm will mostly not find all the possible solutions or does not give you the most optimal solution.

For an RCPSP with a large set of activities, resources and constraints an exact solution often takes too long to find a schedule.
This is why we have chosen for an heuristic algorithm, which mostly trade-offs in completion.
In the next section we will describe this heuristic algorithm.


\newpage


\section{Schedule construction}
\label{text:schedule}

As we have shown in the above, the RCPSP is a complex problem, to find an optimal solution exponential time is needed.
In order to find a solution to the RCPSP in a more timely manner, we use an approximation.
In this chapter we will introduce this approximation, using the \emph{Simple Temporal Problem}, or STP.
STPs are represented with a \emph{Simple Temporal Network} or STN \cite{dechter91}, which is a graph that represents the activities and precedence constraint with nodes and edges respectively.
To represent an RCPSP with an STP more correctly the resource constraints must be represented as well. 
This is done using \emph{Precedence Constraint Posting} (PCP), a method which allows for posting constraints that the prevent the exceeding of the capacities of resources.
The STP is a problem for which a polynomial algorithm is known, thus it is a problem that can be solved in a more timely manner than the original RCPSP.
But, because this is an heuristic, the found schedule will most likely not be the optimal solution.

To explain this approach, we will first illustrate the simple temporal problem with an example.
Then we will show the associated simple temporal network and how it represents the activities and constraints.
To solve the STP, the STN will be represented by a distance graph and a distance matrix.
Then we will show how this representation can be solved using the Floyd-Warshall algorithm.

After this the reduction from RCPSP to STP will be shown, and an explanation of PCP introduced.
To illustrate the reduction we will use Example \ref{exmp:running} and give an STN representation of that example.
Then we show how PCP is used to make a schedule which complies with the resource constraints as well as the precedence constraints.

\subsection{Simple Temporal Problem}
\label{text:STN}
To introduce the STP we will use an example which we will than represent using an STN.

\begin{example}
\label{exmp:stn}
Consider the following events which may occur on a typical work day:
\begin{enumerate}
\item I left my home between 8:05 and 8:10
\item After driving for 20 minutes, I had to stop for an open bridge
\item I waited for 5 to 10 minutes at the bridge
\item At 8:30, I arrived at work 
\end{enumerate}
\end{example}

Questions we would now like to ask ourselves are: ``is this information consistent?'' and ``At what time(s) could I have left my home such that the above story would be true?''. 
Suppose I would have left at 8:10 and drove for 20 minutes and waited 5 minutes at the bridge, I would have arrived at work at 8:35, while I stated that I had arrived at work exactly at 8:30. 
Given the above constraints, it is not hard to discover that the only possible scenario is that I left home at 8:05 and waited only 5 minutes at the bridge.
The challenge now is to implement an algorithm that performs the same kind of reasoning. 
This can be done by regarding this problem as an STP and represent it using an STN.

\subsubsection{Simple Temporal Network}
\label{text:stn_subsec}
The first step is to represent the example above as an STN. 
The nodes in this graph correspond to the events in the story and a directed edge from node $t_i$ to $t_j$ indicates that the event represented by node $t_i$ has to occur before the event represented by node $t_j$.
These edges are called \emph{constraints}.
Additionally, each edge $(t_i, t_j)$ has got a certain \emph{time window} associated with it, which indicates the minimum and maximum delay between the two events represented by time points $t_i$ and $t_j$. 
Each node in this graph is called a \emph{time point}. 
An additional time point is added and refers to \emph{time zero}.
This node is connected to the node that represents the activity with the latest start time.
A convenient time zero for this example is 8:00.
The constraint graph for this example is shown in Figure \ref{fig:stn_example}.

\begin{definition}
\label{text:stn_definition}
An STN is a directed graph, denoted by $G_{stn} = (V_{stn}, E_{stn})$, consisting of:
\begin{itemize}
\item A set of time points $V_{stn} = \{t_0, \ldots, t_n\}$, where $n = |V_{stn}|$.
\item A set of edges $E_{stn} \subset V_{stn} \times V_{stn}$, where each edge $(t_i, t_j) \in E_{stn}$ represents a temporal constraint. 
\end{itemize}
Where each edge $(t_i, t_j) \in E_{stn}$ has a $\mindelay{i}{j} \in \mathbb{N}$ and a $\maxdelay{i}{j} \in \mathbb{N}$, representing the minimum and maximum delay between the two time points.
\end{definition}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
		->,
		>=stealth',
		shorten >=1pt,
		auto,
		node distance=3cm,
	     semithick
	  ]
	
	  \node[state] (1) 						{0};
	  \node[state] (2) [right of=1] 		{L};
	  \node[state] (3) [right of=2] 		{B};
	  \node[state] (4) [right of=3] 		{A};
	
	  \path 	 (1) 	edge [bend left]    	node {[5,10]} 		(2)
	            		edge [bend right] 		node {[30,30]} 	(4)
	       	 (2) 	edge [bend left]		node {[20,20]} 	(3)
	        	 (3) 	edge [bend left]     	node {[5,10]} 		(4);
	        
	\end{tikzpicture}
	\caption{A simple temporal network for Example \ref{exmp:stn}. In this example, the time zero node is called \emph{0}, and the events \emph{leaving home},  \emph{waiting at the bridge} and \emph{arrived at work} are denoted with nodes \emph{L}, \emph{B} and \emph{A} respectively.}
	\label{fig:stn_example}
\end{figure}

The goal of this graph is to tighten the bounds of the time window for each constraint. Using that information, a time window for each time point can be computed. The bounds of the constraints need to be chosen such that if each time point is associated with a start time $s_i$ that lies within its time window, the resulting schedule $S_stn = (s_0,\dots, s_n)$ is consistent.
The time window of the constraints can be tightened by using a distance graph and applying the all-paths-closest-pairs algorithm by Floyd and Warshall, which we will introduce next.

\subsubsection{Distance Graph}
\label{text:distance_graph}
The distance is a graph representation of the STN in which the semantics of the nodes remain the same, but all the edges have one value as the weight instead of a range of values.
In order to reduce the STN to a distance matrix, the edges need to be given a fixed value, instead of a range of a values (as is the case with an STN). 
In order to do so, all edges $(t_i, t_j)$ in the constraint graph are given the weight of the upper bound of the associated time window. 
Additionally, for each edge in the constraint graph, an additional edge is added in opposite direction with a weight equal to the negative lower bound of the time window associated with that edge. 
Each edge now has one value as the weight instead of a range of values. 

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
		->,
		>=stealth',
		shorten >=1pt,
		auto,
		node distance=3cm,
	     semithick
	  ]
	
	  \node[state] (1) 						{0};
	  \node[state] (2) [right of=1] 		{L};
	  \node[state] (3) [right of=2] 		{B};
	  \node[state] (4) [right of=3] 		{A};
	
	  \path 	 (1) 	edge [bend left]    	node {10}	 		(2)
	            		edge [bend right] 		node {30}		 	(4)
	       	 (2) 	edge [bend left]		node {20}		 	(3)
		 			edge [bend left]    	node {-5} 			(1)
	        	 (3) 	edge [bend left]     	node {10}	 		(4)
		 			edge [bend left]		node {-20}	 		(2)
		 	 (4)		edge [bend right] 		node {-30} 		(1)
			 		edge [bend left]     	node {-5} 			(3);
	        
	\end{tikzpicture}
	\caption{A distance graph for Example \ref{exmp:stn}, with edges that have only one value as weight.}
\end{figure}

\begin{algorithm}[H]
\label{alg:distance_graph}
\SetAlgoLined
$V_{dist} = V_{stn}$\;
$E_{dist} = E_{stn}$\;
\ForAll{$(t_i, t_j) \in E_{stn}$}{
	$E_{dist} = E_{dist} \cup \{(t_j, t_i)\}$\;
	$\weight{i}{j} = \maxdelay{i}{j}$\;
	$\weight{j}{i} = -\mindelay{j}{i}$\;
}
\caption{Algorithm for converting an STN into a distance graph}
\end{algorithm}

\begin{definition}
The directional distance graph $G_{dist} = (V_{dist}, E_{dist})$ is generated from the graph $G_{stn}$ in Section \ref{text:stn_subsec} with Algorithm \ref{alg:distance_graph}.
\end{definition}

\subsubsection{Distance Matrix}
From the distance graph, a \emph{Distance Matrix} $D$ can be deduced. A distance matrix can be viewed as a numerical notation of a directed graph. In this $n$ by $n$ matrix, where $n$ is the number of nodes in the original graph, the value at position $D_{i,j}$, where $i$ and $j$ denote the row and the column number respectively, is the weight of the edge from the node represented by $i$ to the node represented by $j$. 

The distance graph can be formatted as a distance matrix $D$ by filling a cell $D_{i,j}$ either with the weight of the edge if there is an edge from the node represented by row $i$ to the the node represented by row $j$ or $\infty$ if there is no edge from the node represented by row $i$ to the the node represented by row $j$.

\begin{figure}[h]
	\centering
	\begin{tabular}{ c | c c c c }
	  			& \textbf{0}	& \textbf{L} 	& \textbf{B} 	& \textbf{A} \\ \hline
	  \textbf{0} 	& 0 			& 10		& $\infty$ 	& 30 \\
	  \textbf{L} 	& -5 		& 0			& 20		& $\infty$ \\
	  \textbf{B} 	& $\infty$ 	& -20		& 0			& 10 \\
	  \textbf{A} 	& -30		& $\infty$	& -5 		& 0 \\
	\end{tabular}
	\caption{The distance matrix for example \ref{exmp:stn}}
	\label{fig:distance_matrix}
\end{figure}

\begin{algorithm}[H]
\label{alg:distance_matrix}
\SetAlgoLined
\ForAll{$(t_i, t_j) \in E_{dist}$}{
	$D_{ij} = \weight{i}{j}$\;
}
\caption{Algorithm for converting a distance graph into a distance matrix}
\end{algorithm}

\begin{definition}
The $|V|$ by $|V|$ distance matrix $D$ is generated from the distance graph $G_{dist}$ in Section \ref{text:distance_graph} with Algorithm \ref{alg:distance_matrix}.
\end{definition}

\subsubsection{Tightening the bounds}
\label{text:floyd}
The distance matrix is a convenient way to represent the distance graph and ultimately the STN because there is an algorithm to compute the new bounds of the time windows of the edges. 

\begin{algorithm}[H]
\label{alg:floyd}
\SetAlgoLined
\For{$k \to |V_{dist}|$}{
	\For{$i \to |V_{dist}|$}{
		\For{$j \to |V_{dist}|$}{
			\If{$D_{ik} + D_{kj} < D_{ij}$}{
				$D_{ij} = D_{ik} + D_{kj}$\;
			}
		}
	}
}
\caption{Algorithm for computing the shortest distance between any pair of nodes in a graph by Floyd and Warshall. }
\end{algorithm}

This algorithm is called the \emph{all-pairs-shortest-paths} (APSP) algorithm \cite{dechter91} is shown in Algorithm \ref{alg:floyd} and was first published in 1962 by Floyd and Warshall.
The algorithm computes the shortest distance between any pair of nodes in a graph.
For Example \ref{exmp:stn} the distance matrix is shown in Figure \ref{fig:stn_dist_matrix}.

\begin{figure}[h]
	\centering
	\begin{tabular}{ c | c c c c }
	  			& \textbf{0}		& \textbf{L} 		& \textbf{B} 		& \textbf{A} \\ \hline
	  \textbf{0} 	& 0 				& \textbf{5}		& \textbf{25} 	& 30 \\
	  \textbf{L} 	& -5 			& 0				& 20			& \textbf{25} \\
	  \textbf{B} 	& \textbf{-25}	& -20			& 0				& \textbf{5} \\
	  \textbf{A} 	& -30			& \textbf{-25}	& -5 			& 0 \\
	\end{tabular}
	\caption{The distance matrix after applying the Floyd-Warshall algorithm on Figure \ref{fig:distance_matrix}}
	\label{fig:stn_dist_matrix}
\end{figure}

The distance matrix shows if their is a time feasible schedule found by the Floyd-Warshall algorithm.
If there entries on the diagonal of the matrix are all $0$, the algorithm has found a time feasible solution. 
If there is a negative value on the diagonal of the distance matrix, a negative cycle is detected and the original STP is unsolvable \cite{dechter91}.
The absolute value of the negative numbers are showing us the lower bounds of the possible times between the two nodes.
The positive numbers of the distance matrix are showing us the upper bounds of the possible times between the two nodes.

\subsection{Reduction from RCPSP to STN}
The notion of an STN as introduced in the previous paragraph can be used to represent the temporal (time related) aspect of the original RCPSP. Let us explain the reduction of the temporal (time-related) aspect of the problem to an STN according to Example \ref{exmp:running}.

The first step of the reduction is taking an empty STN and adding two time points $s_i$ and $e_i$ for each activity $v_i$. 
These time points are then connected with a directed edge from $s_i$ to $e_i$ with time window $[\dur{i}, \dur{i}]$. 
Nodes $s_i$ and $e_i$ can be seen as the start node and end node of activity $v_i$ respectively and the time window associated with the edge that connects these two nodes forces the time between the two time points to be exactly the duration of the activity $v_i$.

Now that the activities are simulated in an STN, it is time to also incorporate the precedence constraints into the STN. This can be quite easily done if one thinks of an RCPSP precedence constraint as being an STN constraint with interval $[0,\infty]$. This means that if two time points $t_i$ and $t_j$ are connected by such an edge, it does not matter how large the interval between the two activities is, as long as it is some positive number. This will simulate the concept of a precedence constraint in an STN.

Using the method outlined in this section we are able to describe Example \ref{exmp:running} as an STN. 

\begin{figure}[h]
	\makebox[\textwidth]{
		\centering
		\begin{tikzpicture}[
			->,
			>=stealth',
			shorten >=1pt,
			auto,
			node distance=2.4cm,
			scale=0.8, 
			every node/.style={transform shape},
		     semithick
		  ]
		  \label{fig:reduced-stn}
		
		  \node[state] (s0) [thick] 	 						{$s_0$};
		  \node[state] (e0) [thick] 	[right of=s0]			{$e_0$};
		  \node[state] (s1) [thick] 	[above right of=e0]	{$s_1$};
		  \node[state] (e1) [thick] 	[right of=s1]			{$e_1$};
		  \node[state] (s2) [thick] 	[right of=e0]			{$s_2$};
		  \node[state] (e2) [thick] 	[right of=s2]			{$e_2$};
		  
		  \node[state] (s3) 	[thick] 	[right of=e1]			{$s_3$};
		  \node[state] (e3) 	[thick] 	[right of=s3]			{$e_3$};
		  \node[state] (s4) 	[thick] 	[right of=e2]			{$s_4$};
		  \node[state] (e4)	[thick] 	[right of=s4]			{$e_4$};
		  \node[state] (s5) 	[thick]	[below right of=e0]	{$s_5$};
		  \node[state] (e5)	[thick]	[right of=s5]			{$e_5$};
		  \node[state] (s6)	[thick] 	[right of=e4]			{$s_6$};
		  \node[state] (e6) 	[thick] 	[right of=s6]			{$e_6$};
		  \node[state] (s7) 	[thick] 	[right of=e6]			{$s_7$};
		  \node[state] (e7) 	[thick] 	[right of=s7]			{$e_7$};
		     
		  \path 		     	(s0) 		edge [thick] node 		{$[0,0]$} 	(e0)
		  		     		(s1) 		edge [thick] node 		{$[3,3]$} 	(e1)
		  		     		(s2) 		edge [thick] node 		{$[2,2]$} 	(e2)
		  		    		(s3) 		edge [thick] node 		{$[2,2]$} 	(e3)
		  		     		(s4) 		edge [thick] node 		{$[1,1]$} 	(e4)
		  		     		(s5) 		edge [thick] node 		{$[5,5]$} 	(e5)
		  		     		(s6) 		edge [thick] node 		{$[1,1]$} 	(e6)
		  		     		(s7) 		edge [thick] node 		{$[0,0]$} 	(e7)
						
						(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s1)
		  				(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s2)
						(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s5)
						(e1) 		edge [dashed] node 		{$[0, \infty]$} 			(s3)
						(e2) 		edge [dashed] node 		{$[0, \infty]$} 			(s4)
						(e3) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e4) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e5) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e6) 		edge [dashed] node 		{$[0, \infty]$} 			(s7);		\end{tikzpicture}
	}
	\caption{In this figure, the temporal aspect of the running example is reduced to an STN. Each pair of nodes $(s_i, e_i)$ represents the start and end time of an activity $v_i$. The dotted edges represent precedence constraints and the solid edges emulate activity durations.}
	\label{fig:stn}
\end{figure}

The STN in Figure \ref{fig:stn} can be represented as a distance graph and ultimately as a distance matrix using the method described in Section \ref{text:STN}. The $16$ by $16$ distance matrix generated for this STN can be found in Appendix A. Applying the Floyd-Warshall algorithm to this matrix, as explained in Section \ref{text:floyd}, yields the matrix found in Appendix B. This matrix contains the tightened bounds for all the time points in the STN in Figure \ref{fig:stn} in such a way that if a value $\delta$ were the be assigned to each time point $t_i$ such that $\delta \in [lb(t_i), ub(t_i)]$, all constraints in this STN are satisfied.

\subsection{Precedence Constraint Posting}
\label{text:PCP}
As seen in the previous section, solving an STP provides us with a set time-feasable schedules. 
This schedule does not take in consideration the resources that are used and it is possible that resources are overused (as is the case in \emph{Schedule A} in Figure \ref{fig:resource_graph}). 
In order to make the time-feasable solution also comply with the resource capacity, a method called \emph{Precendence Constraint Posting} (PCP) \cite{policella07} is used. 

\subsubsection{Minimizing the Makespan}
Since a solution assigns actual values (instead of bounds) to each time point, in order to obtain a solution, a value needs to be given to each time point $t_i$ in the STN. According to the definition of the problem, we would like to minimize the makespan of a project. The schedule in the STN that has the shortest makespan is the schedule that is created by assigning the lower bound of the time window of each time point and use that as a value. This ensures that each time point occurs as soon as possible, without violating the constraints in the STP. This means that all activities also occur as soon as possible, without violating the precedence constraints in the problem definition. The schedule for the running example can be found in Figure \ref{fig:resource_graph}.

\begin{figure}[h]
	\centering
	\inputtikz{schedule_infeasible_profile}
	\caption{A time-feasable schedule for the running example along with the the resource profiles.}
	\label{fig:resource_graph}
\end{figure}

\begin{comment}
\TODO{wat is handiger voor het uitleggen, infeasible profile alleen of de vergelijking van de schedules?}
\begin{figure}[h]
	\centering
	\inputtikz{schedule_comparison}
	\caption{Two different schedules for the running example and their resource profiles. }
	\label{fig:resource_graph}
\end{figure}
\end{comment}

\subsubsection{Contention Peak Detection}
Now that we have got a time-feasable schedule for the running example, it is time to look at the resource usage. For each resource, its usage can be plotted over time in a graph called the \emph{resource profile}. When viewing the resource profile, one can easily determine at what time the resource usage exceeds the capacity of the resource by identifying peaks that have a maximum that lies above the capacity of the resource. The set of activities whose simultaneous execution causes the resource usage to exceed its capacity is called a \emph{contention peak}. There are many methods of finding the exact sets, such as collecting sets of maximal peaks \cite{lombardi10}.

In the time-feasable schedule in Figure \ref{fig:resource_graph}, a contention peak of resource $r_1$ can be found at the interval [$t_0$,$t_2$] and is defined by the set $\{v_1,v_2\}$. Note that the resource profiles for a time-feasable schedule for a larger problem with more activities, constraints and resources can contain multiple contention peaks.

\subsubsection{Conflict Extraction}
\label{text:conflict}
Once contention peaks are identified, an algorithm is able to select the most critical contention peak (for example where the resource capacity is exceeded the most). This contention peak contains a set of activities of which the combined resource usage exceeds the capacity of the resource. In order to reduce the load on a resource, two activities in this set can be scheduled after each other instead of in parallel. Two activities $(v_i,v_j)$ that belong to the same contention peak are called a \emph{conflict}.

The goal is now to identify a pair of resources in the contention peak in such a way that they resolve the contention peak if these activities are scheduled after each other. There are many different methods for determining this pair \cite{lombardi10}, in the running example, the contention peak consists of only two activities, namely $v_1$ and $v_2$.

\subsubsection{Conflict Resolution}
When a conflict ${v_i, v_j}$ is identified, a precedence constraint is added from $v_i$ to $v_j$ only if there is no precedence constraint from $v_j$ to $v_i$ since this would create a cycle in the precede graph. This results in an unsolvable STN since a cycle implies that an activity needs to be executed before itself, which of course, is not possible.

The conflict of the running example consists of $v_1$ and $v_2$ (Section \ref{text:conflict}), so a precedence constraint needs to be added to the STN in Figure \ref{fig:stn} from $e_1$ to $s_2$, meaning that the end of activity $v_1$ should precede the start of activity $v_2$. As described in Section \ref{text:stn_subsec}, this STN can be solved in the same way as the STN in Figure \ref{fig:stn}. This will yield another distance matrix with new bounds for the edges in the distance graph and ultimately new time intervals for the time points. If for each edge, a value within its time window is chosen, the newly added precedence constraint will be respected leading to the result that in every schedule, $v_1$ will precede $v_2$. Because these activities are scheduled after each other, the resource violation of resource $r_1$ in Figure \ref{fig:resource_graph} can no longer occur.

\subsection{Final Schedule}
The last question that remains is how one can deduce an actual schedule from an STN using the Earliest Start Time Algorithm


When the precedence constraint from the conflict resolution is added we can use Algorithm \ref{alg:floyd} from Floyd and Warshall to solve the distance matrix.
For the running example we solved the distance matrix in Appendix \ref{appendix:c}.
After solving the distance matrix a schedule needs to be generated from the distance matrix.

To generate the schedule from the distance matrix we will only look at the values between $s_0$ and every $s_i \in V$.
The absolute value of the negative value in the distance matrix will represent the starting time for each $s_i \in V$.
For the running example we will get the following schedule $S = (0,0,3,3,5,0,6)$.

In this schedule every precedence constraint is met, because every sanding activity is finished before the painting activity for each activity. 
Also the all the painting and sanding is finished before the cleaning is done.
The resource constraints are also met, because the sanding machine isn't used by two activities at the same time.
The same holds for the two painting brushes, because the brushes aren't used by three activities at the same time.
This concludes that the schedule we created is feasible.

\newpage
 
\section{Conclusion}

We have seen that the resource constraint project scheduling problem is a common problem in everyday applications.
We first explored the resource constrained project scheduling problem and its everyday applications.
This gave an insight in the problems that one can encounter in practical applications, as well as the complexity of the problem itself.
To get an even better feel for the problem itself, an example was introduced and the formal definition and notations explained.

We have also seen that the problem is complex and is therefore not easily solved, it is an NP-hard problem.
The common usage of the problem in many practical applications requires a quicker solution to the problem, especially with limited resources and time to create the schedule.
To cope with the constraints and limitations, an approximation technique is used to deliver a quicker solution to the scheduling problem, whilst surrendering optimality.

The approximation method we discussed is called PCP and uses simple temporal networks to represent the activities, precedence constraints, resource constraints and deadline given by the original problem. 
PCP uses an algorithm to solve the STP in reasonable time. 
The solution to the STP provides a schedule of which a resource profile is constructed. 
PCP then smartly determines what activities cause peaks exceeding the resource capacity. 
If such activities peaks are found, it adds additional temporal constraints to the STN to flatten the peaks. 
This process is repeated until there are no more resource limit exceeding peaks. 
It is very unlikely that the solution obtained by using PCP happens to be optimal. 
However, the approach does a good job because the generated schedules can be used in practical applications. 

This paper has shown why there is a need for an approximation to the resource constrained project scheduling problem.
In everyday applications schedules need to be created and this approximation method gives the tools to do so in a timely manner.
Although the schedule will mostly not be optimal, it will give the planner a feasible schedule if this is possible, in a shorter time than the original problem could be solved.

\newpage
\bibliographystyle{plainnat}
\bibliography{references}

\section*{Appendices}

\subsection*{Appendix A}
\label{appendix:a}
\label{text:appendix}
The distance matrix, which is also the input for the Floyd Warshall algorithm:\\
\begin{tabular}{c | cccccccccccccccc}
	&$s_0$	&$s_1$ &$s_2$ &$s_3$ &$s_4$ &$s_5$ &$s_6$ &$s_7$ &$e_0$ &$e_1$ &$e_2$ &$e_3$ &$e_4$ &$e_5$ &$e_6$ &$e_7$\\
\hline
$s_0$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{10}$\\
$s_1$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\textbf{3}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$s_2$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\textbf{2}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$s_3$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\textbf{2}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$s_4$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\textbf{1}$	&$\infty$	&$\infty$	&$\infty$\\
$s_5$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{5}$	&$\infty$	&$\infty$\\
$s_6$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\textbf{0}$	&$\textbf{0}$	&$\textbf{1}$	&$\infty$\\
$s_7$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\textbf{0}$\\
$e_0$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$e_1$	&$\infty$	&$\textbf{-3}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$e_2$	&$\infty$	&$\infty$	&$\textbf{-2}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$e_3$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{-2}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$e_4$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{-1}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$\\
$e_5$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{-5}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$\\
$e_6$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{-1}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$\\
$e_7$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$\\
\end{tabular}

\subsection*{Appendix B}
\label{appendix:b}
The result of the Floyd Warshall algorithm:\\
\begin{tabular}{c | cccccccccccccccc}
	&$s_0$	&$s_1$ &$s_2$ &$s_3$ &$s_4$ &$s_5$ &$s_6$ &$s_7$ &$e_0$ &$e_1$ &$e_2$ &$e_3$ &$e_4$ &$e_5$ &$e_6$ &$e_7$\\
\hline
$s_0$	&$0$	&$4$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$7$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$s_1$	&$0$	&$0$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$3$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$s_2$	&$0$	&$4$	&$0$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$7$	&$2$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$s_3$	&$-3$	&$-3$	&$3$	&$0$	&$5$	&$1$	&$6$	&$7$	&$-3$	&$0$	&$5$	&$2$	&$6$	&$6$	&$7$	&$7$\\
$s_4$	&$-2$	&$2$	&$-2$	&$5$	&$0$	&$2$	&$7$	&$8$	&$-2$	&$5$	&$0$	&$7$	&$1$	&$7$	&$8$	&$8$\\
$s_5$	&$0$	&$4$	&$6$	&$7$	&$8$	&$0$	&$9$	&$10$	&$0$	&$7$	&$8$	&$9$	&$9$	&$5$	&$10$	&$10$	\\
$s_6$	&$-5$	&$-5$	&$-3$	&$-2$	&$-1$	&$-5$	&$0$	&$5$	&$-5$	&$-2$	&$-1$	&$0$	&$0$	&$0$	&$1$	&$5$\\
$s_7$	&$-6$	&$-6$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$0$	&$-6$	&$-3$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$0$\\
$e_0$	&$0$	&$4$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$7$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$e_1$	&$-3$	&$-3$	&$3$	&$4$	&$5$	&$1$	&$6$	&$7$	&$-3$	&$0$	&$5$	&$6$	&$6$	&$6$	&$7$	&$7$\\
$e_2$	&$-2$	&$2$	&$-2$	&$5$	&$6$	&$2$	&$7$	&$8$	&$-2$	&$5$	&$0$	&$7$	&$7$	&$7$	&$8$	&$8$\\
$e_3$	&$-5$	&$-5$	&$1$	&$-2$	&$3$	&$-1$	&$4$	&$5$	&$-5$	&$-2$	&$3$	&$0$	&$4$	&$4$	&$5$	&$5$\\
$e_4$	&$-3$	&$1$	&$-3$	&$4$	&$-1$	&$1$	&$6$	&$7$	&$-3$	&$4$	&$-1$	&$6$	&$0$	&$6$	&$7$	&$7$\\
$e_5$	&$-5$	&$-1$	&$1$	&$2$	&$3$	&$-5$	&$4$	&$5$	&$-5$	&$2$	&$3$	&$4$	&$4$	&$0$	&$5$	&$5$\\
$e_6$	&$-6$	&$-6$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$4$	&$-6$	&$-3$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$4$\\
$e_7$	&$-6$	&$-6$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$0$	&$-6$	&$-3$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$0$\\
\end{tabular}

\subsection*{Appendix C}
\label{appendix:c}
The result of the Floyd Warshall algorithm with the extra precedence constraint:\\
\begin{tabular}{c | cccccccccccccccc}
	&$s_0$	&$s_1$ &$s_2$ &$s_3$ &$s_4$ &$s_5$ &$s_6$ &$s_7$ &$e_0$ &$e_1$ &$e_2$ &$e_3$ &$e_4$ &$e_5$ &$e_6$ &$e_7$\\
\hline
$s_0$	&$0$	&$3$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$6$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$s_1$	&$0$	&$0$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$3$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$s_2$	&$-3$	&$-3$	&$0$	&$4$	&$5$	&$1$	&$6$	&$7$	&$-3$	&$0$	&$2$	&$6$	&$6$	&$6$	&$7$	&$7$\\
$s_3$	&$-3$	&$-3$	&$3$	&$0$	&$5$	&$1$	&$6$	&$7$	&$-3$	&$0$	&$5$	&$2$	&$6$	&$6$	&$7$	&$7$\\
$s_4$	&$-5$	&$-5$	&$-2$	&$2$	&$0$	&$-1$	&$4$	&$5$	&$-5$	&$-2$	&$0$	&$4$	&$1$	&$4$	&$5$	&$5$\\
$s_5$	&$0$	&$3$	&$6$	&$7$	&$8$	&$0$	&$9$	&$10$	&$0$	&$6$	&$8$	&$9$	&$9$	&$5$	&$10$	&$10$	\\
$s_6$	&$-6$	&$-6$	&$-3$	&$-2$	&$-1$	&$-5$	&$0$	&$4$	&$-6$	&$-3$	&$-1$	&$0$	&$0$	&$0$	&$1$	&$4$\\
$s_7$	&$-7$	&$-7$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$0$	&$-7$	&$-4$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$0$\\
$e_0$	&$0$	&$3$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$6$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$e_1$	&$-3$	&$-3$	&$3$	&$4$	&$5$	&$1$	&$6$	&$7$	&$-3$	&$0$	&$5$	&$6$	&$6$	&$6$	&$7$	&$7$\\
$e_2$	&$-5$	&$-5$	&$-2$	&$2$	&$3$	&$-1$	&$4$	&$5$	&$-5$	&$-2$	&$0$	&$4$	&$4$	&$4$	&$5$	&$5$\\
$e_3$	&$-5$	&$-5$	&$1$	&$-2$	&$3$	&$-1$	&$4$	&$5$	&$-5$	&$-2$	&$3$	&$0$	&$4$	&$4$	&$5$	&$5$\\
$e_4$	&$-6$	&$-6$	&$-3$	&$1$	&$-1$	&$-2$	&$3$	&$4$	&$-6$	&$-3$	&$-1$	&$3$	&$0$	&$3$	&$4$	&$4$\\
$e_5$	&$-5$	&$-2$	&$1$	&$2$	&$3$	&$-5$	&$4$	&$5$	&$-5$	&$1$	&$3$	&$4$	&$4$	&$0$	&$5$	&$5$\\
$e_6$	&$-7$	&$-7$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$3$	&$-7$	&$-4$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$3$\\
$e_7$	&$-7$	&$-7$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$0$	&$-7$	&$-4$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$0$\\
\end{tabular}

\end{document}
