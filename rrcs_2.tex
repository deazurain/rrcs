\documentclass{article}
\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[numbers]{natbib}
\usepackage{xcolor}
\usepackage[colorlinks,linkcolor=blue,urlcolor=blue,citecolor=blue]{hyperref}
\usepackage{mathrsfs}
\usepackage{comment}

\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{caption}% http://ctan.org/pkg/caption
%\captionsetup[table]{justification=raggedright, singlelinecheck=off}
\usepackage{amsthm}
\usepackage{nameref}
\usepackage{wrapfig}
\theoremstyle{definition}
\usepackage{pgf}
\usepackage{algorithm2e}
\providecommand{\SetAlgoLined}{\SetLine}
\providecommand{\DontPrintSemicolon}{\dontprintsemicolon}
\newcommand{\inputtikz}[1]{\input{tikz/#1}}

\inputtikz{preamble}

\title{Resource Constrained Project Scheduling: an Approach}
\author{M. van Gelderen  \and
    R.M. de Lange \and
    B. Gris\`el \and
    F. van Tienen}
\date{}

\pagestyle{empty}



\newcommand{\TODO}[1]{{\color{red}\textbf{TODO: #1}}}
\newtheorem{example}{Example}[section]

\newcommand{\res}[0]{\ensuremath{R}} %resources
\newcommand{\av}[2]{\ensuremath{av(r_{#1}, t_{#2})}} %availability of resource #1 at time #2
\newcommand{\capa}[1]{\ensuremath{cap(r_{#1})}} %capacity
\newcommand{\dur}[1]{\ensuremath{dur(v_{#1})}} %durability
\newcommand{\usage}[2]{\ensuremath{usage(v_{#1}, r_{#2})}} %usage of resource #2 by activity #1
\newcommand{\start}[1]{\ensuremath{start(v_{#1})}} %start time
\newcommand{\makespan}[1]{\ensuremath{C_{max}(#1)}} %makespan

\newcommand{\mindelay}[2]{\ensuremath{delay_{min}(t_{#1}, t_{#2})}} %minimum delay
\newcommand{\maxdelay}[2]{\ensuremath{delay_{max}(t_{#1}, t_{#2})}} %maximum delay
\newcommand{\weight}[2]{\ensuremath{weight(t_{#1}, t_{#2})}} %weight

\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}

\begin{document}
\maketitle
\thispagestyle{empty}

\begin{abstract}
\TODO{rewrite when paper finished}
\end{abstract}


\newpage


\section{Introduction}

% Algemene introductie op scheduling
Every day, there are several tasks we have to complete, like going for groceries, visiting the bank and going to work.
And every day we make a schedule in what order to perform these tasks.
Finding a suitable schedule to do all of these activities may sometimes be trivial. 
In other cases however, making a schedule may not be as simple, for instance when some activities have to be done at the same time, or you need a car which is not available at that moment. 
If you have ever found yourself working on a project you will know that it is not always easy to plan all the activities, for instance when there are multiple people involved. 
The problem of finding a suitable schedule is often encountered in our modern lives.
Larger versions of scheduling problems are often found in business applications where immense sets of tasks have to be scheduled in, ideally, the best way possible.

%	Praktijkvoorbeeld 1: Trein repareer schema's
An example of a real life scheduling problem is that of train maintenance scheduling. 
The trains that are utilized by the major Dutch railway company need to undergo regular maintenance. 
This happens in special service bays who might be specialized in maintaining specific parts of a train. 
There are for example service bays that specialize in treating the electrical wiring or in maintaining the wheels.
In scheduling the maintenance of these trains, there are several constraints that need to be satisfied and objectives set by the planner before a schedule can be considered to be `good'. 
It is for example desirable to minimize the time that a train is in maintenance to maximize the use of the trains, this is an objective set by the planner.
But there is a legal obligation to perform maintenance regularly to ensure passenger safety, this is a constraints. 
These demands on the schedule makes finding a suitable schedule in reasonable time a complex task. 

% Praktijkvoorbeeld 2: Airport
Another practical problem is the scheduling of plane flights and servicing them in between. 
For airport scheduling we have to think about refueling, baggage handling, boarding and disembarking among many other activities.
The order in which these activities have to be performed are important as well as the limited availability of for example plane refueling teams and other staff. 
The airlines wish to utilize the aircrafts at maximum capacity, but must keep in mind the safety and regulations that limit their possibilities to do so.

% Name of the scheduling problem: 
This paper deals with a type of scheduling problem called the \emph{Resource Constrained Project Scheduling Problem} (RCPSP). 
This model is flexible enough to give an reasonably accurate representation of for example the train and airport scheduling problems. 
What we mean by reasonably accurate is that a solution to the model can be used as a schedule in practice, but not every scheduling problem can be translated to a RCPSP.
Extensions to the RCPSP can be made to better accommodate for a specific problem but a detailed description of known extensions is beyond the scope of this paper.

%	Structuur van de paper
\subsection{Organization}
\TODO{fix this when we are done}
A detailed explanation of the RCPSP is given in chapter \ref{text:RCPSP}. 
Chapter \ref{text:problem_background} describes the R we will dive  go deeper in to the resource constraint scheduling problem.
Here the different aspects of the resource constraint project scheduling problem will be discussed.
An example of a scheduling problem will be given, along with an intuitive description and formal definitions of the problem.
We will also look into the complexity \ref{text:complex} of the problem, showing why an approximation is needed for practical applications.

The following chapter, \ref{text:schedule} \emph{Schedule Construction}, will deal with the approximation of the solution.
For the approximation, simple temporal networks \ref{text:STN} will be used, which provide with a simpler way of representing a schedule.
The simple temporal networks will be explained using the example from the previous chapter and again giving an intuitive and formal definition.
When a more dynamic way of adjusting the schedule is required, precedence constraint posting \ref{text:PCP} is introduced to the simple temporal networks.
Precedence constraint posting is a technique which allows for changes to a temporal network by introducing new precedence constraints.
The workings of precedence constraint posting will also be explained using the example and giving an intuitive and formal definition.

Combining these two methods gives us a flexible way of approximating a resource constraint project scheduling problem.
Concluding we will show that this combination provides us with a solution capable of scheduling complex problems in continuous environments.
This gives us a robust and effective solution for scheduling in many practical applications.

\newpage

\section{RCPSP}
\label{text:RCPSP}

%	What are scheduling problems?
This chapter provides an overview of what the RCPSP is along with an example that we use to demonstrate ideas and concepts throughout the entire paper. 
In Section \ref{text:RCPSP_description} we introduce the components that are used in describing the RCPSP. 
After we are familiar with the components we can describe our running example which is done in Section \ref{text:running_example_description}. 
The notation that we will use to write denote the components of the RCPSP is introduced using the running example in \ref{text:RCPSP_notation}. 
In Section \ref{text:running_example_definition} we give a short description of the running example using the notation that has been explained in the previous Section. 
This is followed by Section \ref{text:RCPSP_definition} where a short formal definition of the RCPSP is given. 
This chapter concludes with a note on the complexity of the RCPSP. 

\subsection{Problem Introduction}
\label{text:RCPSP_description}
The practical examples given in the introduction provide an idea about the uses of resource constrained project scheduling, but what is it exactly?
The terminology to describe resource constrained project scheduling is and how its problem is built up is introduced in this section.

% activities
Every scheduling problem has a set of \emph{activities} of some sort and this is no different for the RCPSP. 
These activities may also be referred to as jobs or tasks but we will adhere to describing them as activities. 
Examples of activities are sanding the surface of a fence or painting a fence. 
The activities of a project are specified in the RCPSP instance of that project along with the \emph{duration} of each activity. 
% duration
The duration of an activity is usually an estimate of the actual time required to complete the activity because the exact duration is not known beforehand. 
A painter might visit the fence to estimate how long it will take him to sand the fence and how much time he will have to spend painting it. 

% precedence relation
Sometimes activities are dependent on eachother. 
Looking back to the painting project activities, the fence has to be sanded before it can be properly painted. 
This precedence relation between the activities ``sand fence'' and ``paint fence'' is also part of the project description and is often described as a \emph{precedence constraint}. 

% resources
Precedence constraints are just one of the two types of constraints that can be used in the basic RCPSP. 
The other constraint type is concerned with \emph{resources}. 
We extend the painting project to show what a resource is in the RCPSP. 
Lets say that there are now two people working on the painting project. 
However, there is also more work; there is a door that has to be painted as well. 
The problem is that there is only one painting brush available. The painting brushes are a resource. 
The reason for explicitly defining these resources is because they are limited; 
there is only one painting brush available. 
We describe this limit as the capacity of the resource. 
The activities ``paint fence'' and ``paint door'' cannot be executed simultaneously because they both depend on the availability of the painting brush. 
In other words, doing these activities requires two painting brushes which exceeds the resource capacity, thus violating the \emph{resource constraint}. 

% schedule
The activities are the elements that need to be scheduled. 
A \emph{schedule} is nothing more than a lists of the starting times for each activity. 
Such an assignment of starting times can be \emph{feasible} or \emph{infeasible}. 
A schedule is called feasible when it satisfies the precedence constraints as well as the resource constraints. 

% deadline
In some practical applications it is useful to have a deadline for the entire schedule. 
In the case of the painting project, we might be doing the repainting of a house that is going to be sold. 
This means that all the activities in the project must be completed before the date on which the house is going for sale. 
The project manager might want to consider buying an extra painting brush if we fail to find a schedule that completes before the deadline passes. 
Even if a project does not have a real deadline, we can still express that by saying that the project has a deadline of infinitely far in the future. 

% time mapping
It is useful to define the duration and start times of activities in terms of periods. 
In for example the painting project, it makes sense to express the duration of the activities in hours. 
A period in the painting project would then equal one hour. 
In another project a period might equal one day or one minute, it all depends on the context of the project. 
These time periods provide a simple way of dealing with arbitrary time steps. 
The periods can be linearly layed out on a so called time horizon. 
The length of this time horizon is equal to the deadline of the project. 
This means that a schedule can be planned over an unlimited amount of periods if the deadline is infinitely far in the future. 

The notation\footnote{The notation for the RCPSP terminology is presented in a different order than the explanation in this section on purpose. The authors felt that starting with the more easy to grasp concepts such as activities and resources felt more natural here. The notation section however benefits from a different order. } of the concepts explained here is given in Section \ref{text:RCPSP_notation}. But before that, we provide an example RCPSP instance that will be used throughout the paper. 

\subsection{Running example}
\label{text:running_example_description}
This section gives a description of an example RCPSP instance that we will use throughout the paper. 
We will often refer to this example as the \emph{running example}. 

The running example is based on a project that is executed by a house renovation company. 
The project is simplified for our purposes by making it smaller while maintaining the complexity of an actual RCPSP problem. 
The project is concerned with repainting several parts of an old house. 
The parts that need to be repainted are a door, a fence and a wall. 
The door and the fence are made of wood. 
This means that the surfaces of the door and the fence need to be sanded before they can be painted. 
The wall can be repainted without sanding it. 
When the job is finished all of the tools have to be cleaned. 
This gives us six activities: sanding the the door, sanding the fence,  painting the door, painting the fence, painting the wall and cleaning up. 
We also have the following precedence constraints: sanding the door before painting the door, sanding the fence before painting the fence and doing all the painting and sanding activities before the cleanup activity. 

\begin{wraptable}{r}{.34\textwidth}
	\centering
	\vspace{-.6em}
	\begin{tabular}{l|l}
		{Activity} & {Duration} \\
		\hline
		sanding the door & 3 hours\\
		sanding the fence & 2 hours\\
		painting the door & 2 hours\\
		painting the fence & 1 hour\\
		painting the wall & 5 hours\\
		cleaning up & 1 hour\\
		\hline
	\end{tabular}
	\vspace{-.3em}
	\caption{Activity durations}
	\label{table:activity_durations}
	\vspace{-.6em}
\end{wraptable}

It is to be expected that the time required to complete an activity is not the same for all the activities in the project. 
Each activity can have a different estimated \emph{duration}.
The painting project manager specifies the duration for each of the activities in whole hours, because the exact duration is not so critical. 
The activity durations for the painting project are summarized in Table \ref{table:activity_durations}. 
The manager would like to plan the activities on whole hours. 
This means that the periods in the time horizon have a length of one hour. 
To save on travelling costs, the manager wants to try and find a schedule where the painters have to visit the old house only once. 
The maximum time that the painters can spend on a project in a single day is 10 hours. 
This means that the project has a real deadline and that it is set to 10 periods. 

Normally there are enough tools available for everyone to work with.
Unfortunately, the crew\footnote{The crew could be seen as a resource by itself. We will however assume that there are enough worksmen available so that we do not have to take them in account as a limited resource. } has a very limited amount of tools this time around.
There are two painting brushes available and only one sanding machine. 
This makes it impossible to sand more than one surface at the same time and to paint more than two surfaces at the same time.
The painting brushes and the sanding machines are the resources of this project. 

We will assume that the painters greatly appreciate their privacy and prefer to work alone on an activity. This means that the sanding and painting activities will each require at most one sanding machine or painting brush at a time. 
The cleanup activity however requires all of the tools at once. 

The manager of the painting project wants to find a schedule that is feasible. 
In other words, the manager wants a schedule that does not violate any of the precedence constraints, fits within the time horizon and at no point in time exceeds any of the the resource capacities. 

\subsection{Notation}
\label{text:definitions}
The notation for the RCPSP used in this paper is introduced in this section. We explain the notation by means of the running example and several illustrations. The notation itself is heavily based on work by \citet{brucker99}. 

The \emph{time horizon} is a mapping of real-world time to model-time. It is indicated by the so called time horizon $T \in \mathbb{N}$.
The periods within the time horizon $t=1,2,3,\ldots,T$ are also notated as $t_j$ which means the $j$-th time period in the time horizon $T$. 
The time period $t_j$ corresponds to the time interval $(t-1,t]$. 
The real-time length of a period can be arbitrarily chosen and changed without affecting the underlying scheduling problem instance. 

\begin{figure}[ht]
	\centering
	\inputtikz{activity_graph}
	\caption{Activity graph for the running example.}
	\label{fig:activity_graph}
\end{figure}

\TODO{HIER IS MICK GEBLEVEN, DE REST VAN NOTATION ETC MOET NOG NAGEKEKEN OWORDEN}

\emph{Activities} are specified by a set $V = \{v_1, \ldots, v_n\}$.
This is a set of activities where the total amount of activities is $n = |V|$ and each element $v_i \in V$ from this set represents the i-th activity of the project.
In the running example we have six activities: sanding the the door $v_1$, sanding the fence $v_2$,  painting the door $v_3$, painting the fence $v_4$, painting the wall $v_5$ and cleaning the painting brushes $v_6$. 
Which gives us the total set of activities $V = \{v_1, \ldots, v_6\}$ with $n = 6$ for the running example.
These activities are represented in Figure \ref{fig:activity_graph} as blocks.

The \emph{duration} for each activity $v_i \in V$ is specified by $\dur{i} \in \mathbb{N}$.
In the running example the activities have the following duration: $\dur{1} = 3, \dur{2} = 2, \dur{3} = 2, \dur{4} = 1, \dur{5} = 5, \dur{6} = 1$. 
The duration of each activity in the running example is represented by the length of the block in Figure \ref{fig:activity_graph}.

The \emph{extended activity set} is specified by $W = V \cup \{v_0, v_{n+1}\}$.
Which consists of the activity set $V$ and incorporates a unique dummy beginning activity $v_0$ and a unique dummy ending activity $v_{n+1}$. 
These dummy activities have a duration of $0$ periods.
For the running example we have a set $W = \{v_0, \ldots v_7\}$.
Figure \ref{fig:activity_graph} shows $W$ for the running example.
In the figure $v_0$ and $v_7$ are filled with a shade of gray, because they have a duration of $0$ instead of a duration relative to the width. 

\emph{Precedence constraints} are specified by a set $E \subseteq \{(v_i, v_j) | v_i \in V, v_j \in V, v_i \neq v_j\}$
This means that a precedence relation between activities $v_i$ and $v_j$, where $v_j$ can be started only after $v_i$ is finished, is represented as $(v_i, v_j) \in E$.
The running example has several precedence constraints between the activities, which make up the following set $E = \{(v_1, v_3), (v_2, v_4), (v_3, v_6), (v_4, v_6), (v_5, v_6)\}$.
Precedence constraints for the dummy activities $v_0$ and $v_7$ are added to ensure that the starting activity starts before every other activity and that every activity is completed before the ending activity.
Figure \ref{fig:activity_graph} shows the precedence constraints for the running example, represented as arrows between the nodes.
The precedence constraints in Figure \ref{fig:activity_graph} are reduced to a minimum, because you can reduce for example $(v_0,v_6), (v_0, v_5), (v_5, v_6)$ to $(v_0, v_5), (v_5, v_6)$.

The \emph{constraints graph} is specified by a directed graph $G = (V, E)$.
It consists of the activities $V$, which are represented as nodes, and the precedence constraints $E$, which are represented as connections between nodes.
The constraints graph for the running example is represented in Figure \ref{fig:activity_graph}.

\begin{figure}[h]
	\centering
	\inputtikz{usage}
	\caption{Activities, resources and the relation between them for the running example.}
	\label{fig:resource_graph}
\end{figure}

\emph{Resources} are specified by a set $R = \{r_1, \ldots, r_m\}$.
The total amount of resources is $m \in \mathbb{N}$ and each resource is represented by a unique identifier. %identifier??
In the running example we have two resources ($m = 2$): the sanding machine $r_1$ and the painting brushes $r_2$.
Which gives us the total set of resources $R = \{r_1, r_2\}$.

The \emph{capacity} of each resource $r_i \in R$ is specified by a function $\capa{i} \in \mathbb{N}$.
For the running example the capacity for the resources are: $\capa{1} = 1, \capa{1} = 2$, because we have one sanding machine and two painting brushes.
These capacities of the running example are shown in Figure \ref{fig:resource_graph}.

The \emph{usage} of an activity $v_i \in V$ consumes of a resource $r_j \in \res$ during its execution is specified by the function $\usage{i}{j} \in \mathbb{N}$.
The running example has the following usages: $\usage{1}{2} = 1, \usage{2}{2} = 1, \usage{3}{1} = 1, \usage{4}{1} = 1, \usage{5}{1} = 1, \usage{6}{1} = 2$.
In Figure \ref{fig:resource_graph} the usage of the running example is expressed as a relation between activities and resources, where the number between the relation is the amount of usage.

\begin{figure}[h]
	\centering
	\inputtikz{schedule_feasible}
	\caption{A feasible schedule for the running example. }
	\label{fig:time_feasible_schedule}
\end{figure}

A \emph{schedule} is specified by a set $S = \{\start{1}, \ldots, \start{n}\}$.
In this schedule each activity $v_i \in V$ has a starting time $\start{i}$ which is defined in the schedule $S$.
When we create a schedule for the running and we also take in account the precedence constraints, you could get the following schedule:
\{0, 0, 3, 2, 0, 6\}. \TODO{geen set maar een vector want volgorde is belangrijk}
This schedule is called a \emph{time feasible schedule} and is represented in Figure \ref{fig:time_feasible_schedule}. 

The \emph{makespan} of a schedule $S$ is the number of periods required to finish the project using the schedule $S$. The makespan is notated as $\makespan{S} \in T$.
In Figure \ref{fig:time_feasible_schedule} we have a time feasible schedule, where the makespan is optimized to a minimum and all the precedence constraints hold.

\begin{figure}[h]
	\centering
	\inputtikz{schedule_feasible_profile}
	\caption{Overview of the resource usage by activities over time. }
	\label{fig:feasible_schedule}
\end{figure}

\TODO{MAN O MAN O MAN waar is nou het hele "oh shit nee wat hebben we gedaan, als we naar de resources kijken kan schedule A helemaal niet" aka neem de lezer mee in je verhaal en laat hem eerst denken van "ja ja ja idd idd" en schud hem dan wakker omdat we al 10 minuten bezig zijn met een schedule die eigenlijk helemaal niet uitvoerbaar is gebleven???????????????????????????????????????
??????????????????????????????????????????????????????????????? Le Mick est very sad}

A \emph{feasible schedule} is denoted as $S_f$ and takes in account both the precedence and the resource constraints.
The schedule from Figure \ref{fig:time_feasible_schedule} is also represented in Figure \ref{fig:feasible_schedule} as Schedule A.
In Figure \ref{fig:feasible_schedule} you can see the capacity of the resources, denoted by the dotted line, and the usage of resources at a certain time, denoted by the height of the activities in the graph.
This makes it easy to see that the capacity of $r_1$ (the sanding machine) is exceeded from $t_0$ till $t_2$, because they can't sand the fence and the door at the same time.
This means that Schedule A is a time feasible schedule, but not a feasible schedule.
An example of a feasible schedule is shown in Figure \ref{fig:feasible_schedule}, Schedule B.

The \emph{availability} of an activity $v_i \in V$ at a time $t_j \in T$ is specified by a function $\av{i}{j} \in \mathbb{N}$.
For example if you only paint one object in the running example at $t_1$, the availability of $r_2$ is $\av{2}{1} = 1$ because we have two painting brushes and only one is used.
In Figure \ref{fig:feasible_schedule} the availability of a resource can be deduced trough capacity, the dotted line, and the sum of the usage on a given time, the height of the activities in the graph. 

\subsection{Formal definition of the running example}

In Example \ref{exmp:running} we define the formal definition of the \emph{Running Example} by using the definitions in subsection \ref{text:definitions}.
\begin{example}
\label{exmp:running}
$V = \{v_1, \ldots, v_6\}$\\
$E = \{(v_1, v_3), (v_2, v_4), (v_3, v_6), (v_4, v_6), (v_5, v_6)\}$\\
$R = \{r_1, r_2\}$\\
$\dur{1} = 3, \dur{2} = 2, \dur{3} = 2, \dur{4} = 1, \dur{5} = 5, \dur{6} = 1$\\
$\usage{1}{2} = 1, \usage{2}{2} = 1, \usage{3}{1} = 1, \usage{4}{1} = 1, \usage{5}{1} = 1, \usage{6}{1} = 2$\\
$\capa{1} = 2, \capa{2} = 1$
\end{example}


\subsection{RCPSP formal definition}

\begin{definition}
Given:
A set of activities $V = v_1, \ldots, v_n$, a set of resources $R = \{r_1, \ldots, r_m\}$ and a set of precedence constraints $E \subseteq  \{(v_i, v_j) | v_i \in V, v_j \in V, v_i \neq v_j\}$.
Where each activity $v_i \in V$ has a duration $\dur{i} \in \mathbb{N}$ and each resource $r_j \in R$ has a capacity $\capa{j} \in \mathbb{N}$. 
And each activity $v_i \in V$ can use the capacity of a resource $r_j \in R$ with usage $\usage{i}{j} \in \mathbb{N}$.

Find:
A feasible schedule $S_f = \{s_1, \ldots s_n\}$, consisting of starting times for the activities in $V$.
Where each precedence constraint in $E$ holds, denoted by $\forall (v_i, v_j) \in E$ $(\start{i} + \dur{i} \leq \start{j})$.
And no resource exceeds its capacity in usage at any time in the schedule, denoted by $\forall r_i \in R, t_j \in T (0 \leq \av{i}{j})$.
\end{definition}


\subsection{Complexity of the RCPSP}
\label{text:complex}
The RCPSP belongs to the class of \emph{NP-complete} problems as is proven in \TODO{Reference a paper where this is proven}.
This means that increases processing power do not notably speed up the generation of solutions to the problem.
An exact algorithm for the RCPSP problem isn't possible in polynomial time.

Another approach in finding solutions for the RCPSP is a heuristic algorithm.
A heuristic algorithm can find solutions for the RCPSP problem and does notably speed up the generation of solutions to the problem when the processing power increases.
To achieve this heuristic algorithm trades completeness, optimality, accuracy, and/or precision for speed.
This means for example that an heuristic algorithm sometimes will not find all the possible solutions or that an heuristic algorithm sometimes doesn't give you the most optimal solution.

For an RCPSP with a large set of activities, resources and constraints an exact solution often takes too long to find a solution.
This is why we have chosen for a heuristic algorithm, which mostly trade-offs in completion.
In the next section we will describe this heuristic algorithm.


\newpage


\section{Schedule construction}
\label{text:schedule}

As we have shown in the above, the RCPSP is a complex problem, to find an optimal solution exponential time is needed.
In order to find a solution to the RCPSP in a more timely manner, we use an approximation.
In this chapter we will introduce this approximation, using the \emph{Simple Temporal Problem}, or STP.
STPs are represented with a Simple Temporal Network or STN, which is a graph that represents the activities and precedence constraint with nodes and edges respectively.
To represent an RCPSP with an STP more correctly the resource constraints must be represented as well. 
This is done using \emph{Precedence Constraint Posting} (PCP), a method which allows for posting constraints that the prevent the exceeding of the capacities of resources.
The STP is a problem for which a polynomial algorithm is known, thus it is a problem that can be solved in a more timely manner than the original RCPSP.
But, because this is an heuristic, the found schedule will most likely not be the optimal solution.

To explain this approach, we will first illustrate the simple temporal problem with an example.
Then we will show the associated simple temporal network and how it represents the activities and constraints.
To solve the STP, the STN will be represented by a distance graph and a distance matrix.
Then we will show how this representation can be solved using the Floyd-Warshall algorithm.

After this the reduction from RCPSP to STP will be shown, and an explanation of PCP introduced.
To illustrate the reduction we will use Example \ref{exmp:running} and give an STN representation of that example.
Then we show how PCP is used to make a schedule which complies with the resource constraints as well as the precedence constraints.

\subsection{Simple Temporal Problem}
\label{text:STN}
To introduce the STP we will use an example which we will than represent using an STN.

\subsubsection{Example}
\begin{example}
\label{exmp:stn}
Consider the following events which may occur on a typical work day:
\begin{enumerate}
\item I left my home between 8:05 and 8:10
\item After driving for 20 minutes, I had to stop for an open bridge
\item I waited for 5 to 10 minutes at the bridge
\item At 8:30, I arrived at work 
\end{enumerate}
\end{example}

Questions we would now like to ask ourselves are: ``is this information consistent?'' and ``At what time(s) could I have left my home such that the above story would be true?''. 
Suppose I would have left at 8:10 and drove for 20 minutes and waited 5 minutes at the bridge, I would have arrived at work at 8:35, while I stated that I had arrived at work exactly at 8:30. 
Given the above constraints, it is not hard to discover that the only possible scenario is that I left home at 8:05 and waited only 5 minutes at the bridge.
The challenge now is to implement an algorithm that performs the same kind of reasoning. 
This can be done by regarding this problem as an STP and represent it using an STN.

\subsubsection{Simple Temporal Network}
\label{text:stn_subsec}
The first step is to represent the example above as an STN. 
The nodes in this graph correspond to the events in the story and a directed edge from node $t_i$ to $t_j$ indicates that the event represented by node $t_i$ has to occur before the event represented by node $t_j$.
These edges are called \emph{constraints}.
Additionally, each edge $(t_i, t_j)$ has got a certain \emph{time window} associated with it, which indicates the minimum and maximum delay between the two events represented by time points $t_i$ and $t_j$. 
Each node in this graph is called a \emph{time point}. 
An additional time point is added and refers to \emph{time zero}.
This node is connected to the node that represents the activity with the latest start time.
A convenient time zero for this example is 8:00.
The constraint graph for this example is shown in Figure \ref{fig:stn_example}.

\begin{definition}
\label{text:stn_definition}
An STN is a directed graph, denoted by $G_{stn} = (V_{stn}, E_{stn})$, consisting of:
\begin{itemize}
\item A set of time points $V_{stn} = \{t_0, \ldots, t_n\}$, where $n = |V_{stn}|$.
\item A set of edges $E_{stn} \subset V_{stn} \times V_{stn}$, where each edge $(t_i, t_j) \in E_{stn}$ represents a temporal constraint. 
\end{itemize}
Where each edge $(t_i, t_j) \in E_{stn}$ has a $\mindelay{i}{j} \in \mathbb{N}$ and a $\maxdelay{i}{j} \in \mathbb{N}$, representing the minimum and maximum delay between the two time points.
\end{definition}

\begin{figure}[h]
	\label{fig:stn_example}
	\centering
	\begin{tikzpicture}[
		->,
		>=stealth',
		shorten >=1pt,
		auto,
		node distance=3cm,
	     semithick
	  ]
	
	  \node[state] (1) 						{0};
	  \node[state] (2) [right of=1] 		{L};
	  \node[state] (3) [right of=2] 		{B};
	  \node[state] (4) [right of=3] 		{A};
	
	  \path 	 (1) 	edge [bend left]    	node {[5,10]} 		(2)
	            		edge [bend right] 		node {[30,30]} 	(4)
	       	 (2) 	edge [bend left]		node {[20,20]} 	(3)
	        	 (3) 	edge [bend left]     	node {[5,10]} 		(4);
	        
	\end{tikzpicture}
	\caption{A simple temporal network for Example \ref{exmp:stn}. In this example, the time zero node is called \emph{0}, and the events \emph{leaving home},  \emph{waiting at the bridge} and \emph{arrived at work} are denoted with nodes \emph{L}, \emph{B} and \emph{A} respectively.}
\end{figure}

The goal of this graph is to tighten the bounds of the time window for each time point, in such a way that if each time point is associated with a value that lies within its time window, the schedule is consistent. 
This can be done using a distance graph and applying the all-paths-closest-pairs algorithm by Floyd and Warshall, which we will introduce next.

\subsubsection{Distance Graph}
\label{text:distance_graph}
The distance is a graph representation of the STN in which the semantics of the nodes remain the same, but all the edges have one value as the weight instead of a range of values.
In order to reduce the STN to a distance matrix, the edges need to be given a fixed value, instead of a range of a values (as is the case with an STN). 
In order to do so, all edges $(t_i, t_j)$ in the constraint graph are given the weight of the upper bound of the associated time window. 
Additionally, for each edge in the constraint graph, an additional edge is added in opposite direction with a weight equal to the negative lower bound of the time window associated with that edge. 
Each edge now has one value as the weight instead of a range of values. 

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
		->,
		>=stealth',
		shorten >=1pt,
		auto,
		node distance=3cm,
	     semithick
	  ]
	
	  \node[state] (1) 						{0};
	  \node[state] (2) [right of=1] 		{L};
	  \node[state] (3) [right of=2] 		{B};
	  \node[state] (4) [right of=3] 		{A};
	
	  \path 	 (1) 	edge [bend left]    	node {10}	 		(2)
	            		edge [bend right] 		node {30}		 	(4)
	       	 (2) 	edge [bend left]		node {20}		 	(3)
		 			edge [bend left]    	node {-5} 			(1)
	        	 (3) 	edge [bend left]     	node {10}	 		(4)
		 			edge [bend left]		node {-20}	 		(2)
		 	 (4)		edge [bend right] 		node {-30} 		(1)
			 		edge [bend left]     	node {-5} 			(3);
	        
	\end{tikzpicture}
	\caption{A distance graph for Example \ref{exmp:stn}, with edges that have only one value as weight.}
\end{figure}

\begin{algorithm}[H]
\label{alg:distance_graph}
\SetAlgoLined
$V_{dist} = V_{stn}$\;
$E_{dist} = E_{stn}$\;
\ForAll{$(t_i, t_j) \in E_{stn}$}{
	$E_{dist} = E_{dist} \cup \{(t_j, t_i)\}$\;
	$\weight{i}{j} = \maxdelay{i}{j}$\;
	$\weight{j}{i} = -\mindelay{j}{i}$\;
}
\caption{Algorithm for converting an STN into a distance graph}
\end{algorithm}

\begin{definition}
The directional distance graph $G_{dist} = (V_{dist}, E_{dist})$ is generated from the graph $G_{stn}$ in Section \ref{text:stn_subsec} with Algorithm \ref{alg:distance_graph}.
\end{definition}

\subsubsection{Distance Matrix}
From the distance graph, a \emph{Distance Matrix} $D$ can be deduced. A distance matrix can be viewed as a numerical notation of a directed graph. In this $n$ by $n$ matrix, where $n$ is the number of nodes in the original graph, the value at position $D_{i,j}$, where $i$ and $j$ denote the row and the column number respectively, is the weight of the edge from the node represented by $i$ to the node represented by $j$. 

The distance graph can be formatted as a distance matrix $D$ by filling a cell $D_{i,j}$ either with the weight of the edge if there is an edge from the node represented by row $i$ to the the node represented by row $j$ or $\infty$ if there is no edge from the node represented by row $i$ to the the node represented by row $j$.

\begin{figure}[h]
	\centering
	\begin{tabular}{ c | c c c c }
	  			& \textbf{0}	& \textbf{L} 	& \textbf{B} 	& \textbf{A} \\ \hline
	  \textbf{0} 	& 0 			& 10		& $\infty$ 	& 30 \\
	  \textbf{L} 	& -5 		& 0			& 20		& $\infty$ \\
	  \textbf{B} 	& $\infty$ 	& -20		& 0			& 10 \\
	  \textbf{A} 	& -30		& $\infty$	& -5 		& 0 \\
	\end{tabular}
	\caption{The distance matrix for example \ref{exmp:stn}}
	\label{fig:distance_matrix}
\end{figure}

\begin{algorithm}[H]
\label{alg:distance_matrix}
\SetAlgoLined
\ForAll{$(t_i, t_j) \in E_{dist}$}{
	$D_{ij} = \weight{i}{j}$\;
}
\caption{Algorithm for converting a distance graph into a distance matrix}
\end{algorithm}

\begin{definition}
The $|V|$ by $|V|$ distance matrix $D$ is generated from the distance graph $G_{dist}$ in Section \ref{text:distance_graph} with Algorithm \ref{alg:distance_matrix}.
\end{definition}

\subsubsection{Tightening the bounds}
\label{text:floyd}
The distance matrix is a convenient way to represent the distance graph and ultimately the STN because there is an algorithm to compute the new bounds of the time windows of the edges. 

\begin{algorithm}[H]
\label{alg:floyd}
\SetAlgoLined
\For{$k \to |V_{dist}|$}{
	\For{$i \to |V_{dist}|$}{
		\For{$j \to |V_{dist}|$}{
			\If{$D_{ik} + D_{kj} < D_{ij}$}{
				$D_{ij} = D_{ik} + D_{kj}$\;
			}
		}
	}
}
\caption{Algorithm for computing the shortest distance between any pair of nodes in a graph by Floyd and Warshall. }
\end{algorithm}

This algorithm is called the \emph{all-pairs-shortest-paths} (APSP) algorithm is shown in Algorithm \ref{alg:floyd} and was first published in 1962 by Floyd and Warshall \TODO{Reference}.
The algorithm computes the shortest distance between any pair of nodes in a graph.
For Example \ref{exmp:stn} the distance matrix is shown in Figure \ref{fig:stn_dist_matrix}.

\begin{figure}[h]
	\centering
	\begin{tabular}{ c | c c c c }
	  			& \textbf{0}		& \textbf{L} 		& \textbf{B} 		& \textbf{A} \\ \hline
	  \textbf{0} 	& 0 				& \textbf{5}		& \textbf{25} 	& 30 \\
	  \textbf{L} 	& -5 			& 0				& 20			& \textbf{25} \\
	  \textbf{B} 	& \textbf{-25}	& -20			& 0				& \textbf{5} \\
	  \textbf{A} 	& -30			& \textbf{-25}	& -5 			& 0 \\
	\end{tabular}
	\caption{The distance matrix after applying the Floyd-Warshall algorithm on Figure \ref{fig:distance_matrix}}
	\label{fig:stn_dist_matrix}
\end{figure}

The distance matrix shows us if their is a time feasible schedule found by the Floyd and Warshall algorithm.
When there aren't any other numbers then $0$ on the diagonal, the algorithm has found a time feasible solution.
The absolute value of the negative numbers are showing us the lower bounds of the possible times between the two nodes.
The positive numbers of the distance matrix are showing us the upper bounds of the possible times between the two nodes.

\subsection{Reduction from RCPSP to STN}
The notion of an STN as introduced in the previous paragraph can be used to represent the temporal (time related) aspect of the original RCPSP. Let us explain the reduction of the temporal (time-related) aspect of the problem to an STN according to Example \ref{exmp:running}.

The first step of the reduction is taking an empty STN and adding two time points $s_i$ and $e_i$ for each activity $v_i$. 
These time points are then connected with a directed edge from $s_i$ to $e_i$ with time window $[\dur{i}, \dur{i}]$. 
Nodes $s_i$ and $e_i$ can be seen as the start node and end node of activity $v_i$ respectively and the time window associated with the edge that connects these two nodes forces the time between the two time points to be exactly the duration of the activity $v_i$.

Now that the activities are simulated in an STN, it is time to also incorporate the precedence constraints into the STN. This can be quite easily done if one thinks of an RCPSP precedence constraint as being an STN constraint with interval $[0,\infty]$. This means that if two time points $t_i$ and $t_j$ are connected by such an edge, it does not matter how large the interval between the two activities is, as long as it is some positive number. This will simulate the concept of a precedence constraint in an STN.

Using the method outlined in this section we are able to describe Example \ref{exmp:running} as an STN. 

\begin{figure}[h]
	\makebox[\textwidth]{
		\centering
		\begin{tikzpicture}[
			->,
			>=stealth',
			shorten >=1pt,
			auto,
			node distance=2.4cm,
			scale=0.8, 
			every node/.style={transform shape},
		     semithick
		  ]
		  \label{fig:reduced-stn}
		
		  \node[state] (s0) [thick] 	 						{$s_0$};
		  \node[state] (e0) [thick] 	[right of=s0]			{$e_0$};
		  \node[state] (s1) [thick] 	[above right of=e0]	{$s_1$};
		  \node[state] (e1) [thick] 	[right of=s1]			{$e_1$};
		  \node[state] (s2) [thick] 	[right of=e0]			{$s_2$};
		  \node[state] (e2) [thick] 	[right of=s2]			{$e_2$};
		  
		  \node[state] (s3) 	[thick] 	[right of=e1]			{$s_3$};
		  \node[state] (e3) 	[thick] 	[right of=s3]			{$e_3$};
		  \node[state] (s4) 	[thick] 	[right of=e2]			{$s_4$};
		  \node[state] (e4)	[thick] 	[right of=s4]			{$e_4$};
		  \node[state] (s5) 	[thick]	[below right of=e0]	{$s_5$};
		  \node[state] (e5)	[thick]	[right of=s5]			{$e_5$};
		  \node[state] (s6)	[thick] 	[right of=e4]			{$s_6$};
		  \node[state] (e6) 	[thick] 	[right of=s6]			{$e_6$};
		  \node[state] (s7) 	[thick] 	[right of=e6]			{$s_7$};
		  \node[state] (e7) 	[thick] 	[right of=s7]			{$e_7$};
		     
		  \path 		     	(s0) 		edge [thick] node 		{$[0,0]$} 	(e0)
		  		     		(s1) 		edge [thick] node 		{$[3,3]$} 	(e1)
		  		     		(s2) 		edge [thick] node 		{$[2,2]$} 	(e2)
		  		    		(s3) 		edge [thick] node 		{$[2,2]$} 	(e3)
		  		     		(s4) 		edge [thick] node 		{$[1,1]$} 	(e4)
		  		     		(s5) 		edge [thick] node 		{$[5,5]$} 	(e5)
		  		     		(s6) 		edge [thick] node 		{$[1,1]$} 	(e6)
		  		     		(s7) 		edge [thick] node 		{$[0,0]$} 	(e7)
						
						(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s1)
		  				(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s2)
						(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s5)
						(e1) 		edge [dashed] node 		{$[0, \infty]$} 			(s3)
						(e2) 		edge [dashed] node 		{$[0, \infty]$} 			(s4)
						(e3) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e4) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e5) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e6) 		edge [dashed] node 		{$[0, \infty]$} 			(s7);		\end{tikzpicture}
	}
	\caption{In this figure, the temporal aspect of the running example is reduced to an STN. Each pair of nodes $(s_i, e_i)$ represents the start and end time of an activity $v_i$. The dotted edges represent precedence constraints and the solid edges emulate activity durations.}
	\label{fig:stn}
\end{figure}

The STN in Figure \ref{fig:stn} can be represented as a distance graph and ultimately as a distance matrix using the method described in Section \ref{text:STN}. The $16$ by $16$ distance matrix generated for this STN can be found in Appendix A. Applying the Floyd-Warshall algorithm to this matrix, as explained in Section \ref{text:floyd}, yields the matrix found in Appendix B. This matrix contains the tightened bounds for all the time points in the STN in Figure \ref{fig:stn} in such a way that if a value $\delta$ were the be assigned to each time point $t_i$ such that $\delta \in [lb(t_i), ub(t_i)]$, all constraints in this STN are satisfied.

\subsection{Precedence Constraint Posting}
\label{text:PCP}
As seen in the previous section, solving an STP provides us with a set time-feasable schedules. 
This schedule does not take in consideration the resources that are used and it is possible that resources are overused (as is the case in \emph{Schedule A} in Figure \ref{fig:resource_graph}). 
In order to make the time-feasable solution also comply with the resource capacity, a method called \emph{Precendence Constraint Posting} (PCP) is used. 

\subsubsection{Minimizing the Makespan}
Since a solution assigns actual values (instead of bounds) to each time point, in order to obtain a solution, a value needs to be given to each time point $t_i$ in the STN. According to the definition of the problem, we would like to minimize the makespan of a project. The schedule in the STN that has the shortest makespan is the schedule that is created by assigning the lower bound of the time window of each time point and use that as a value. This ensures that each time point occurs as soon as possible, without violating the constraints in the STP. This means that all activities occur as soon as possible, without violating the precedence constraints in the problem definition. The schedule for the running example can be found in Figure \ref{fig:resource_graph}.

\begin{figure}[h]
	\centering
	\inputtikz{schedule_infeasible_profile}
	\caption{A time-feasable schedule for the running example along with the the resource profiles.}
	\label{fig:resource_graph}
\end{figure}

\begin{comment}
\TODO{wat is handiger voor het uitleggen, infeasible profile alleen of de vergelijking van de schedules?}
\begin{figure}[h]
	\centering
	\inputtikz{schedule_comparison}
	\caption{Two different schedules for the running example and their resource profiles. }
	\label{fig:resource_graph}
\end{figure}
\end{comment}

\subsubsection{Contention Peak Detection}
Now that we have got a time-feasable schedule for the running example, it is time to look at the resource usage. For each resource, its usage can be plotted over time in a graph called the \emph{resource profile}. When viewing the resource profile, one can easily determine at what time the resource usage exceeds the capacity of the resource by identifying peaks that have a maximum that lies above the capacity of the resource. The set of activities whose simultaneous execution causes the resource usage to exceed its capacity is called a \emph{contention peak}. There are many methods of finding the exact sets, such as collecting sets of maximal peaks \TODO{reference}.

In the time-feasable schedule in Figure \ref{fig:resource_graph}, a contention peak of resource $r_1$ can be found at the interval [$t_0$,$t_2$] and is defined by the set $\{v_1,v_2\}$. Note that the resource profiles for a time-feasable schedule for a larger problem with more activities, constraints and resources can contain multiple contention peaks.

\subsubsection{Conflict Extraction}
Once contention peaks are identified, an algorithm is able to select the most critical contention peak (for example where the resource capacity is exceeded the most). This contention peak contains a set of activities of which the combined resource usage exceeds the capacity of the resource. In order to reduce the load on a resource, two activities in this set can be scheduled after each other instead of in parallel. Two activities $(v_i,v_j)$ that belong to the same contention peak are called a \emph{conflict}.

The goal is now to identify a pair of resources in the contention peak in such a way that they resolve the contention peak if these activities are scheduled after each other. There are many different methods for determining this pair \TODO{reference}, in the running example, the contention peak consists of only two activities, namely $v_1$ and $v_2$.

\subsubsection{Conflict Resolution}
When a conflict is identified, a precedence is added between

\TODO{
	-Temporal lower bound for each activity can be computed via the shortest path algorithm
		-Uitleggen huidige STN niet werkt (alleen temporal en niet resource feasable)
		-Globale idee van resource leveling using PCP
		-Algoritmw voor resource leveling (volgens ESTA en aan de hand van example)
		-Algemeen en Formeel algoritme
		}

\subsection{Final Schedule}

\TODO{
		-Hoe maak je van dat STN weer een schedule
		-Hoe voldoet het schedule (aan alle constraints)
}

\subsection{Algorithm}

\newpage

\TODO{
 - Continuous planning aanstippen in future work \\
 - Bronvermeldingen moeten er echt in, probeer het te doen terwijl je schrijft \\
 - PCP Mag iets duidelijker naar voren komen in hoofdstuk 'schedule construction' 3.2 wordt dus PCP \\
 - Goeie presentatie ;D! \\
 - Laat ergens weten dat we ervanuit gaan dat we de makespan willen minimaliseren en dat daardoor het een logische aanpak lijkt om uit te gaan van een basis schedule geconstrueerd door de earliest start time techniek. \\
 }

\newpage
 
\section{Conclusion}

We have seen that the resource constraint project scheduling problem is a common problem in everyday applications.
These applications often operate in dynamic environments, which pose many external constraints on the schedules.
The common usage of the problem in dynamic environment requires a smart approach to the problem, especially with limited resources and time.
To cope with these constraints and problems, some techniques are applied to provide with a more flexible and robust schedule.
Flexibility is key in providing a schedule that can function in a dynamic environment, handling the uncertainties which may occur.

We first explored the resource constraint scheduling problem and its applications.
This gave an insight in the problems that one can encounter in practical applications, as well as the complexity of the problem itself.
Due to the complexity of the problem it is not possible to quickly give an optimal solution for a schedule.
Because in the practical applications a quicker solving of the problem is required to keep up with the pace of the schedule execution, approximations are needed.

The approximation we discussed used simple temporal networks to represent the resources, activities and constraints given by the original problem.
The simple temporal problem can be solved more easily than the resource constraint project scheduling problem, but remains an approximation.
This means that the problem will not likely give an optimal solution and might possibly be unable to find a solution, although the original problem was feasible.

Combining this more simple representation or approximation of the problem with the precedence constraint posting method allows for the creation of a flexible and robust schedule.
In this manner the schedule can easily be adopted to changes in the environment.
In a dynamic or continuous application these changes occur quite often and must be dealt with in minimal time.

The simple temporal network and precedence constraint posting solutions offer a way of quick and effective scheduling in more complex, dynamic applications.
The paper has shown how these techniques can be used to give an effective approximation of the resource constraint project scheduling problem.
Although the results may not be optimal or sometimes might not even be found by this approximation, the quick results makes it an eligible solution for these application.

\newpage
\bibliographystyle{plainnat}
\bibliography{references}

\section{Appendices}

\subsection{Appendix A}
\label{appendix:a}
\label{text:appendix}
The distance matrix, which is also the input for the Floyd Warshall algorithm:\\
\begin{tabular}{c | cccccccccccccccc}
	&$s_0$	&$s_1$ &$s_2$ &$s_3$ &$s_4$ &$s_5$ &$s_6$ &$s_7$ &$e_0$ &$e_1$ &$e_2$ &$e_3$ &$e_4$ &$e_5$ &$e_6$ &$e_7$\\
\hline
$s_0$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{10}$\\
$s_1$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\textbf{3}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$s_2$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\textbf{2}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$s_3$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\textbf{2}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$s_4$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\textbf{1}$	&$\infty$	&$\infty$	&$\infty$\\
$s_5$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{5}$	&$\infty$	&$\infty$\\
$s_6$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\textbf{0}$	&$\textbf{0}$	&$\textbf{1}$	&$\infty$\\
$s_7$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\textbf{0}$\\
$e_0$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$e_1$	&$\infty$	&$\textbf{-3}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$e_2$	&$\infty$	&$\infty$	&$\textbf{-2}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$e_3$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{-2}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$\\
$e_4$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{-1}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$\\
$e_5$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{-5}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$\\
$e_6$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{-1}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$\\
$e_7$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\infty$	&$\textbf{0}$\\
\end{tabular}

\subsection{Appendix B}
\label{appendix:b}
The result of the Floyd Warshall algorithm:\\
\begin{tabular}{c | cccccccccccccccc}
	&$s_0$	&$s_1$ &$s_2$ &$s_3$ &$s_4$ &$s_5$ &$s_6$ &$s_7$ &$e_0$ &$e_1$ &$e_2$ &$e_3$ &$e_4$ &$e_5$ &$e_6$ &$e_7$\\
\hline
$s_0$	&$0$	&$4$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$7$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$s_1$	&$0$	&$0$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$3$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$s_2$	&$0$	&$4$	&$0$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$7$	&$2$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$s_3$	&$-3$	&$-3$	&$3$	&$0$	&$5$	&$1$	&$6$	&$7$	&$-3$	&$0$	&$5$	&$2$	&$6$	&$6$	&$7$	&$7$\\
$s_4$	&$-2$	&$2$	&$-2$	&$5$	&$0$	&$2$	&$7$	&$8$	&$-2$	&$5$	&$0$	&$7$	&$1$	&$7$	&$8$	&$8$\\
$s_5$	&$0$	&$4$	&$6$	&$7$	&$8$	&$0$	&$9$	&$10$	&$0$	&$7$	&$8$	&$9$	&$9$	&$5$	&$10$	&$10$	\\
$s_6$	&$-5$	&$-5$	&$-3$	&$-2$	&$-1$	&$-5$	&$0$	&$5$	&$-5$	&$-2$	&$-1$	&$0$	&$0$	&$0$	&$1$	&$5$\\
$s_7$	&$-6$	&$-6$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$0$	&$-6$	&$-3$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$0$\\
$e_0$	&$0$	&$4$	&$6$	&$7$	&$8$	&$4$	&$9$	&$10$	&$0$	&$7$	&$8$	&$9$	&$9$	&$9$	&$10$	&$10$	\\
$e_1$	&$-3$	&$-3$	&$3$	&$4$	&$5$	&$1$	&$6$	&$7$	&$-3$	&$0$	&$5$	&$6$	&$6$	&$6$	&$7$	&$7$\\
$e_2$	&$-2$	&$2$	&$-2$	&$5$	&$6$	&$2$	&$7$	&$8$	&$-2$	&$5$	&$0$	&$7$	&$7$	&$7$	&$8$	&$8$\\
$e_3$	&$-5$	&$-5$	&$1$	&$-2$	&$3$	&$-1$	&$4$	&$5$	&$-5$	&$-2$	&$3$	&$0$	&$4$	&$4$	&$5$	&$5$\\
$e_4$	&$-3$	&$1$	&$-3$	&$4$	&$-1$	&$1$	&$6$	&$7$	&$-3$	&$4$	&$-1$	&$6$	&$0$	&$6$	&$7$	&$7$\\
$e_5$	&$-5$	&$-1$	&$1$	&$2$	&$3$	&$-5$	&$4$	&$5$	&$-5$	&$2$	&$3$	&$4$	&$4$	&$0$	&$5$	&$5$\\
$e_6$	&$-6$	&$-6$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$4$	&$-6$	&$-3$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$4$\\
$e_7$	&$-6$	&$-6$	&$-4$	&$-3$	&$-2$	&$-6$	&$-1$	&$0$	&$-6$	&$-3$	&$-2$	&$-1$	&$-1$	&$-1$	&$0$	&$0$\\
\end{tabular}

\end{document}
