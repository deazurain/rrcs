\documentclass{article}
\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[numbers]{natbib}
\usepackage{xcolor}
\usepackage[colorlinks,linkcolor=blue,urlcolor=blue,citecolor=blue]{hyperref}
\usepackage{mathrsfs}
\usepackage{comment}

\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{caption}% http://ctan.org/pkg/caption
%\captionsetup[table]{justification=raggedright, singlelinecheck=off}
\usepackage{amsthm}
\usepackage{nameref}
\usepackage{wrapfig}
\theoremstyle{definition}
\usepackage{pgf}
\newcommand{\inputtikz}[1]{\input{tikz/#1}}

\inputtikz{preamble}

\title{Resource Constrained Project Scheduling: an Approach}
\author{M. van Gelderen  \and
    R.M. de Lange \and
    B. Gris\`el \and
    F. van Tienen}
\date{}

\pagestyle{empty}



\newcommand{\TODO}[1]{{\color{red}\textbf{TODO: #1}}}
\newtheorem{example}{Example}[section]

\newcommand{\res}[0]{\ensuremath{R}} %resources
\newcommand{\av}[2]{\ensuremath{av(r_{#1}, t_{#2})}} %availability of resource #1 at time #2
\newcommand{\capa}[1]{\ensuremath{cap(r_{#1})}} %capacity
\newcommand{\dur}[1]{\ensuremath{dur(v_{#1})}} %durability
\newcommand{\usage}[2]{\ensuremath{usage(v_{#1}, r_{#2})}} %usage of resource #2 by activity #1
\newcommand{\start}[1]{\ensuremath{start(v_{#1})}} %start time
\newcommand{\makespan}[1]{\ensuremath{C_{max}(#1)}} %makespan

\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}

\begin{document}
\maketitle
\thispagestyle{empty}

\begin{abstract}
\TODO{rewrite when paper finished}
\end{abstract}


\newpage


\section{Introduction}

% Algemene introductie op scheduling
Every day, there are several tasks we have to complete, like going for groceries, visiting the bank and going to work.
And every day we make a schedule in what order to perform these tasks.
Finding a suitable schedule to do all of these activities may sometimes be trivial. 
In other cases however, making a schedule may not be as simple, for instance when some activities have to be done at the same time, or you need a car which is not available at that moment. 
If you have ever found yourself working on a project you will know that it is not always easy to plan all the activities, for instance when there are multiple people involved. 
The problem of finding a suitable schedule is often encountered in our modern lives.
Larger versions of scheduling problems are often found in business applications where immense sets of tasks have to be scheduled in, ideally, the best way possible.

%	Praktijkvoorbeeld 1: Trein repareer schema's
An example of a real life scheduling problem is that of train maintenance scheduling. 
The trains that are utilized by the major Dutch railway company need to undergo regular maintenance. 
This happens in special service bays who might be specialized in maintaining specific parts of a train. 
There are for example service bays that specialize in treating the electrical wiring or in maintaining the wheels.
In scheduling the maintenance of these trains, there are several constraints that need to be satisfied and objectives set by the planner before a schedule can be considered to be `good'. 
It is for example desirable to minimize the time that a train is in maintenance to maximize the use of the trains, this is an objective set by the planner.
But there is a legal obligation to perform maintenance regularly to ensure passenger safety, this is a constraints. 
These demands on the schedule makes finding a suitable schedule in reasonable time a complex task. 

% Praktijkvoorbeeld 2: Airport
Another practical problem is the scheduling of plane flights and servicing them in between. 
For airport scheduling we have to think about refueling, baggage handling, boarding and disembarking among many other activities.
The order in which these activities have to be performed are important as well as the limited availability of for example plane refueling teams and other staff. 
The airlines wish to utilize the aircrafts at maximum capacity, but must keep in mind the safety and regulations that limit their possibilities to do so.

% Name of the scheduling problem: 
This paper deals with a type of scheduling problem called the \emph{Resource Constrained Project Scheduling Problem} (RCPSP). 
This model is flexible enough to give an reasonably accurate representation of for example the train and airport scheduling problems. 
What we mean by reasonably accurate is that a solution to the model can be used as a schedule in practice, but not every scheduling problem can be translated to a RCPSP.
Extensions to the RCPSP can be made to better accommodate for a specific problem but a detailed description of known extensions is beyond the scope of this paper.

%	Structuur van de paper
\subsection{Organization}
\TODO{fix this when we are done}
A detailed explanation of the RCPSP is given in chapter \ref{text:RCPSP}. 
Chapter \ref{text:problem_background} describes the R we will dive  go deeper in to the resource constraint scheduling problem.
Here the different aspects of the resource constraint project scheduling problem will be discussed.
An example of a scheduling problem will be given, along with an intuitive description and formal definitions of the problem.
We will also look into the complexity \ref{text:complex} of the problem, showing why an approximation is needed for practical applications.

The following chapter, \ref{text:schedule} \emph{Schedule Construction}, will deal with the approximation of the solution.
For the approximation, simple temporal networks \ref{text:STN} will be used, which provide with a simpler way of representing a schedule.
The simple temporal networks will be explained using the example from the previous chapter and again giving an intuitive and formal definition.
When a more dynamic way of adjusting the schedule is required, precedence constraint posting \ref{text:PCP} is introduced to the simple temporal networks.
Precedence constraint posting is a technique which allows for changes to a temporal network by introducing new precedence constraints.
The workings of precedence constraint posting will also be explained using the example and giving an intuitive and formal definition.

Combining these two methods gives us a flexible way of approximating a resource constraint project scheduling problem.
Concluding we will show that this combination provides us with a solution capable of scheduling complex problems in continuous environments.
This gives us a robust and effective solution for scheduling in many practical applications.

\newpage

\section{RCPSP}
\label{text:RCPSP}

%	What are scheduling problems?
This chapter provides an overview of what the RCPSP is along with an example that we use to demonstrate ideas and concepts through the entire paper. 
In Section \ref{text:RCPSP_description} we introduce the components that are used in describing a RCPSP instantation. After we are used to these components we can describe our running example which is done in Section  \ref{text:running_example_description}. The notation that we will use to write denote the components of the RCPSP is introduced using the running example in \ref{text:RCPSP_notation}. In Section \ref{text:running_example_definition} we can give a short description using the notation that has been explained in the previous section. This is followed by section \ref{text:RCPSP_definition} where we give a short formal definition of the RCPSP. This chapter concludes with a note on the complexity of the RCPSP. 

We will then give a running example, which will be used throughout this paper to make the problem more tangible.
Using this example, we will illustrate the formal definition of the resource constraint project scheduling problem.
With this formal definition and a good sense what the problem holds, the complexity of the problem will be discussed.

Before we go into the examples and definitions, let us first see what resource constrained scheduling problems are.
Scheduling problems are problems in which several activities need to be put into a schedule.
For the execution of these activities, there is often a limited amount of resources available.
The schedule is called feasible when there is a solution that puts all activities in the schedule in such a way that they are all executable by the resources needed and do not overlap with conflicting tasks.
This is a simple form of scheduling in the examples, that we will discuss further on, more constraints will be added.
Such as for example the precedence constraint, in which one task needs to be finished before the other can start.
These extra constraints place more demands on the schedule for it to be feasible.


\subsection{Problem Introduction}
We now have an idea about the uses of resource constraint scheduling, but what is it exactly?
The RCPSP concerns itself with finding start times for a set of activities so that the schedule is feasible and usually optimized in some way.
This optimization might be either the shortest processing time or the most efficient use of resources.
In this paper we will focus on the shortest processing time.
The scheduling problem consists of a few main elements: activities, resources and constraints.

Activities, also called tasks or jobs, are the tasks that need to be executed or jobs that need to be performed.
These activities are the elements that need to be scheduled in the first place.
Resources are the machines or personnel or equipment needed to perform a specific activity.
Resources can often perform a specific function and have a maximum capacity of simultaneous activities.

Constraints can be any number of limiting factors to which a specific activity, resource or entire schedule should hold.
A constraint can be the fact that there is a limited number of one type of resource available (\emph{resource constraint}).
Lets say there are two people working on a house painting project and there is only one painting brush available. 
The activities ``paint the fence'' and ``paint the door'' cannot be executed simultaneously because they both depend on the availability of the single painting brush. 
Another constraint can be that one specific activity needs to be finished before another specific activity can be performed (\emph{precedence constraint}).
Take for example the painting of a fence, the activity ``sand the fence surface" has to be completed before the activity ``paint the fence" can be executed. 

In some practical applications it is useful to have a deadline for the entire schedule. 
If for example the house painting project has to be done before a fixed date because the house will be sold, it would be good to know if there is a schedule which can realize this. 
In other words, we would like to know if there exists a assignment of start times for all the activities so that the resource requirements and the time requirements are met and the project is finished befor the deadline.
The project manager might want to consider buying an extra painting brush if such a schedule cannot be devised for the current resources and activities. 

\TODO{dit is een raar stukje, valt uit de toon}
A project is scheduled on a so called time horizon.
This time horizon defines the periods over which the activities can be scheduled.
Lets say that the house painting manager expresses the duration of activities in hours.
It might make sense to schedule the activities on whole hours.

The aspects of the RCPSP will be discussed in detail while introducing a running example and introducing a formal notation used in this paper now that we have provided a mental overview of what the RCPSP is. 

\subsection{Running example}
In this paper we will use a simple running example based on a painting job to show you what the RCPSP problem is.
After we explained the RCPSP, we will use this running example to explain the schedule construction in Section \ref{text:schedule}.

For the running example we are looking into a painting company which has several projects to do.
One of these projects is painting some parts of a house, which is a simple example of a real RCPSP problem.
The problem consists of workers that need to finish three painting jobs: a door, a fence and a wall.
Because the the door and the fence are made of wood, both surfaces needs to be sanded first.
These constraints are called \emph{precedence constraints}.
Sanding is not necessary for the wall, because the wall is made of bricks.
When the job is finished all painting brushes and the sanding machine needs to be cleaned and this can only be done when all the painting and sanding is finished.
This gives us six \emph{activities}: sanding the the door, sanding the fence,  painting the door, painting the fence, painting the wall and cleaning the painting brushes.
We also have the following precedence constraints: sanding the door before painting the door, sanding the fence before painting the fence and all the painting and sanding activities needs to be done before cleaning the painting brushes.

Because the size of each surface in the painting jobs differs, not each activity takes the same amount of time to finish.
Each activity can have a different \emph{duration}.
They define the duration for each of the activities in whole hours, because this makes it easier to schedule. \TODO{they, the project manager?}
The total schedule is made in the \emph{time horizon}, where each hour is mapped to one step in the time horizon. \TODO{ref table}
For simplicity's sake, we assume that they know the exact duration for each activity:

\begin{wraptable}{r}{.38\textwidth}
	\centering
	\begin{tabular}{l|l}
		{Activity} & {Duration} \\
		\hline
		sanding the door & 3 hours\\
		sanding the fence & 2 hours\\
		painting the door & 2 hours\\
		painting the fence & 1 hour\\
		painting the wall & 5 hours\\
		cleaning up & 1 hour\\
		\hline
	\end{tabular}
	\caption{Activity durations}
\end{wraptable}

Normally there are enough tools available for everyone to work with.
Unfortunately, the crew has a very limited amount of tools this time around.
These tools are often called \emph{resources}.
So now they only have two painting brushes and one sanding machine, which makes it impossible to sand more than one surface at the same time and to paint more than two surfaces at the same time.
These constraints are called \emph{resource constraints}.
This shows us that the \emph{capacity} of painting surfaces at the same time is two and the capacity of sanding surfaces at the same time is one.

Since every sanding job uses the sanding machine as a resource, the usage of sanding the door and sanding the fence is one sanding machine.
Also every painting job uses the painting brush as a resource, so that painting the door, painting the fence and painting the wall all have a usage of one painting brush.
There is only one activity left, cleaning the painting brushes, which will use both of the painting brushes resource.
Because a sanding activity doesn't use a painting brush, a painting activity doesn't use a sanding machine and cleaning the painting brushes doesn't use a sanding machine all of the activities never use another resource.

The painters want to make a \emph{schedule} to complete the project.
They define a schedule by assigning a start time to each activity.
One of the requirements for the schedule is that the sanding has to be finished before the painting.
The other requirement is that the painting and the sanding both have to be finished before the cleaning.
As last they also have to keep in mind that they have limited tools available and for example can't sand two surfaces at the same time.
The painters want to make a schedule, where they define each starting time for the activities in such a way that the resulting schedule is feasible. 
The painters also have a lot of other projects to be done, so the painter not only want a feasible schedule but also want to optimize the time in which they finish all the activities.
This means that they want to finishes all activities in the least amount of time.

\subsection{Notation}
\label{text:definitions}
The notation for the RCPSP used in this paper is introduced in this section. We explain the notation trough images and the running example. The notation itself is based on work by \citet{brucker99}. 

The \emph{time horizon} is a mapping of real-world time to model-time is indicated by the so called time horizon $T \in \mathbb{N}$.
The periods within the time horizon $t=1,2,3,\ldots,T$ are also notated as $t_j$ which means the $j$-th time period in the time horizon $T$. 
The time period $t_j$ corresponds to the time interval $(t-1,t]$. 

\begin{figure}[ht]
	\centering
	\inputtikz{activity_graph}
	\caption{Activity graph for the running example.}
	\label{fig:activity_graph}
\end{figure}

\emph{Activities} are specified by a set $V = \{v_1, \ldots, v_n\}$.
This is a set of activities where the total amount of activities is $n = |V|$ and each element $v_i \in V$ from this set represents the i-th activity of the project.
In the running example we have six activities: sanding the the door $v_1$, sanding the fence $v_2$,  painting the door $v_3$, painting the fence $v_4$, painting the wall $v_5$ and cleaning the painting brushes $v_6$. 
Which gives us the total set of activities $V = \{v_1, \ldots, v_6\}$ with $n = 6$ for the running example.
These activities are represented in Figure \ref{fig:activity_graph} as blocks.

The \emph{duration} for each activity $v_i \in V$ is specified by $\dur{i} \in \mathbb{N}$.
In the running example the activities have the following duration: $\dur{1} = 3, \dur{2} = 2, \dur{3} = 2, \dur{4} = 1, \dur{5} = 5, \dur{6} = 1$. 
The duration of each activity in the running example is represented by the length of the block in Figure \ref{fig:activity_graph}.

The \emph{extended activity set} is specified by $W = V \cup \{v_0, v_{n+1}\}$.
Which consists of the activity set $V$ and incorporates a unique dummy beginning activity $v_0$ and a unique dummy ending activity $v_{n+1}$. 
These dummy activities have a duration of $0$ periods.
For the running example we have a set $W = \{v_0, \ldots v_7\}$.
Figure \ref{fig:activity_graph} shows $W$ for the running example.
In the figure $v_0$ and $v_7$ are filled with a shade of gray, because they have a duration of $0$ instead of a duration relative to the width. 

\emph{Precedence constraints} are specified by a set $E \subseteq \{(v_i, v_j) | v_i \in V, v_j \in V, v_i \neq v_j\}$
This means that a precedence relation between activities $v_i$ and $v_j$, where $v_j$ can be started only after $v_i$ is finished, is represented as $(v_i, v_j) \in E$.
The running example has several precedence constraints between the activities, which make up the following set $E = \{(v_1, v_3), (v_2, v_4), (v_3, v_6), (v_4, v_6), (v_5, v_6)\}$.
Precedence constraints for the dummy activities $v_0$ and $v_7$ are added to ensure that the starting activity starts before every other activity and that every activity is completed before the ending activity.
Figure \ref{fig:activity_graph} shows the precedence constraints for the running example, represented as arrows between the nodes.
The precedence constraints in Figure \ref{fig:activity_graph} are reduced to a minimum, because you can reduce for example $(v_0,v_6), (v_0, v_5), (v_5, v_6)$ to $(v_0, v_5), (v_5, v_6)$.

The \emph{constraints graph} is specified by a directed graph $G = (V, E)$.
It consists of the activities $V$, which are represented as nodes, and the precedence constraints $E$, which are represented as connections between nodes.
The constraints graph for the running example is represented in Figure \ref{fig:activity_graph}.

\begin{figure}[h]
	\centering
	\inputtikz{usage}
	\caption{Activities, resources and the relation between them for the running example.}
	\label{fig:resource_graph}
\end{figure}

\emph{Resources} are specified by a set $R = \{r_1, \ldots, r_m\}$.
The total amount of resources is $m \in \mathbb{N}$ and each resource is represented by a unique identifier. %identifier??
In the running example we have two resources ($m = 2$): the sanding machine $r_1$ and the painting brushes $r_2$.
Which gives us the total set of resources $R = \{r_1, r_2\}$.

The \emph{capacity} of each resource $r_i \in R$ is specified by a function $\capa{i} \in \mathbb{N}$.
For the running example the capacity for the resources are: $\capa{1} = 1, \capa{1} = 2$, because we have one sanding machine and two painting brushes.
These capacities of the running example are shown in Figure \ref{fig:resource_graph}.

The \emph{usage} of an activity $v_i \in V$ consumes of a resource $r_j \in \res$ during its execution is specified by the function $\usage{i}{j} \in \mathbb{N}$.
The running example has the following usages: $\usage{1}{2} = 1, \usage{2}{2} = 1, \usage{3}{1} = 1, \usage{4}{1} = 1, \usage{5}{1} = 1, \usage{6}{1} = 2$.
In Figure \ref{fig:resource_graph} the usage of the running example is expressed as a relation between activities and resources, where the number between the relation is the amount of usage.

\begin{figure}[h]
	\centering
	\inputtikz{schedule_feasible}
	\caption{A feasible schedule for the running example. }
	\label{fig:time_feasible_schedule}
\end{figure}

A \emph{schedule} is specified by a set $S = \{\start{1}, \ldots, \start{n}\}$.
In this schedule each activity $v_i \in V$ has a starting time $\start{i}$ which is defined in the schedule $S$.
When we create a schedule for the running and we also take in account the precedence constraints, you could get the following schedule:
\{0, 0, 3, 2, 0, 6\}. \TODO{geen set maar een vector want volgorde is belangrijk}
This schedule is called a \emph{time feasible schedule} and is represented in Figure \ref{fig:time_feasible_schedule}. 

The \emph{makespan} of a schedule $S$ is the number of periods required to finish the project using the schedule $S$. The makespan is notated as $\makespan{S} \in T$.
In Figure \ref{fig:time_feasible_schedule} we have a time feasible schedule, where the makespan is optimized to a minimum and all the precedence constraints hold.

\begin{figure}[h]
	\centering
	\inputtikz{schedule_feasible_profile}
	\caption{Overview of the resource usage by activities over time. }
	\label{fig:feasible_schedule}
\end{figure}

\TODO{MAN O MAN O MAN waar is nou het hele "oh shit nee wat hebben we gedaan, als we naar de resources kijken kan schedule A helemaal niet" aka neem de lezer mee in je verhaal en laat hem eerst denken van "ja ja ja idd idd" en schud hem dan wakker omdat we al 10 minuten bezig zijn met een schedule die eigenlijk helemaal niet uitvoerbaar is gebleven???????????????????????????????????????
??????????????????????????????????????????????????????????????? Le Mick est very sad}

A \emph{feasible schedule} is denoted as $S_f$ and takes in account both the precedence and the resource constraints.
The schedule from Figure \ref{fig:time_feasible_schedule} is also represented in Figure \ref{fig:feasible_schedule} as Schedule A.
In Figure \ref{fig:feasible_schedule} you can see the capacity of the resources, denoted by the dotted line, and the usage of resources at a certain time, denoted by the height of the activities in the graph.
This makes it easy to see that the capacity of $r_1$ (the sanding machine) is exceeded from $t_0$ till $t_2$, because they can't sand the fence and the door at the same time.
This means that Schedule A is a time feasible schedule, but not a feasible schedule.
An example of a feasible schedule is shown in Figure \ref{fig:feasible_schedule}, Schedule B.

The \emph{availability} of an activity $v_i \in V$ at a time $t_j \in T$ is specified by a function $\av{i}{j} \in \mathbb{N}$.
For example if you only paint one object in the running example at $t_1$, the availability of $r_2$ is $\av{2}{1} = 1$ because we have two painting brushes and only one is used.
In Figure \ref{fig:feasible_schedule} the availability of a resource can be deduced trough capacity, the dotted line, and the sum of the usage on a given time, the height of the activities in the graph. 

\subsection{Formal definition of the running example}

In Example \ref{exmp:running} we define the formal definition of the \emph{Running Example} by using the definitions in subsection \ref{text:definitions}.
\begin{example}
\label{exmp:running}
$V = \{v_1, \ldots, v_6\}$\\
$E = \{(v_1, v_3), (v_2, v_4), (v_3, v_6), (v_4, v_6), (v_5, v_6)\}$\\
$R = \{r_1, r_2\}$\\
$\dur{1} = 3, \dur{2} = 2, \dur{3} = 2, \dur{4} = 1, \dur{5} = 5, \dur{6} = 1$\\
$\usage{1}{2} = 1, \usage{2}{2} = 1, \usage{3}{1} = 1, \usage{4}{1} = 1, \usage{5}{1} = 1, \usage{6}{1} = 2$\\
$\capa{1} = 2, \capa{2} = 1$
\end{example}


\subsection{RCPSP formal definition}

\begin{definition}
Given:
A set of activities $V = v_1, \ldots, v_n$, a set of resources $R = \{r_1, \ldots, r_m\}$ and a set of precedence constraints $E \subseteq  \{(v_i, v_j) | v_i \in V, v_j \in V, v_i \neq v_j\}$.
Where each activity $v_i \in V$ has a duration $\dur{i} \in \mathbb{N}$ and each resource $r_j \in R$ has a capacity $\capa{j} \in \mathbb{N}$. 
And each activity $v_i \in V$ can use the capacity of a resource $r_j \in R$ with usage $\usage{i}{j} \in \mathbb{N}$.

Find:
A feasible schedule $S_f = \{s_1, \ldots s_n\}$, consisting of starting times for the activities in $V$.
Where each precedence constraint in $E$ holds, denoted by $\forall (v_i, v_j) \in E$ $(\start{i} + \dur{i} \leq \start{j})$.
And no resource exceeds its capacity in usage at any time in the schedule, denoted by $\forall r_i \in R, t_j \in T (0 \leq \av{i}{j})$.
\end{definition}


\subsection{Complexity of the RCPSP}
\label{text:complex}
The RCPSP belongs to the class of \emph{NP-complete} problems as is proven in \TODO{Reference a paper where this is proven}.
This means that increases processing power do not notably speed up the generation of solutions to the problem.
An exact algorithm for the RCPSP problem isn't possible in polynomial time.

Another approach in finding solutions for the RCPSP is a heuristic algorithm.
A heuristic algorithm can find solutions for the RCPSP problem and does notably speed up the generation of solutions to the problem when the processing power increases.
To achieve this heuristic algorithm trades completeness, optimality, accuracy, and/or precision for speed.
This means for example that an heuristic algorithm sometimes will not find all the possible solutions or that an heuristic algorithm sometimes doesn't give you the most optimal solution.

For an RCPSP with a large set of activities, resources and constraints an exact solution often takes too long to find a solution.
This is why we have chosen for a heuristic algorithm, which mostly trade-offs in completion.
In the next section we will describe this heuristic algorithm.


\newpage


\section{Schedule construction}
\label{text:schedule}

As shown, the RCPSP is a complex problem, to find an optimal solution exponential time is needed.
In order to find a solution to the RCPSP in a more timely manner, we use an approximation.
In this chapter we will introduce this approximation, using the \emph{Simple Temporal Problem}, or STP.
STPs are represented with a graph, or Simple Temporal Network, which holds the 
The STP is a problem for which a polynomial algorithm is known, thus it is a problem that can be solved in a more timely manner than the original RCPSP.
To represent an RCPSP with an STP,  \emph{Precedence Constraint Posting} (PCP) is used.

%		-Wat gaan we benaderen (relevantie van STN)
The use of an STN to approximate an RCPSP is specifically practical, while the STN allows us to save multiple starting times per activity.
This makes the STN more of a collection of feasible schedules, which gives the schedule represented by it extra flexibility.
Furthermore, the simple temporal problem is a problem which is quite similar to path finding and is thus solvable in polynomial time.
These two important features make the STN a useful approximation of the RCPSP, which is neither flexible, nor solvable in polynomial time.

%		-Geen volledige reductie, dus niet alle instanties worden chill afgebeeld 
The STN does not completely represent the original RCPSP, but is just an approximation.
There are cases in which the RCPSP is feasible, but using an STN will not give a working schedule.
\TODO{wat zijn deze gevallen? Hebben we een voorbeeld? Of laten we dat weg?}
This is an important shortcoming of this approximation.
Given the advantages in speed and flexibility, this shortcoming has to be taken for granted in using RCPSP in a dynamic environment.

\subsection{Simple Temporal Problem}
\label{text:STN}
Let us first introduce a notion of such a \emph{Simple Temporal Network} (STN) using a basic example. 
Note that the problem in question is called a \emph{Simple Temporal Problem} (STP) which is represented using an STN.

\subsubsection{Example}
\begin{example}
\label{exmp:stn}
Consider the following events which may occur on a typical work day:
\begin{enumerate}
\item I left my home between 8:05 and 8:10
\item After driving for 20 minutes, I had to stop for an open bridge
\item I waited for 5 to 10 minutes at the bridge
\item At 8:30, I arrived at work 
\end{enumerate}
\end{example}

Questions we would now like to ask ourselves are: ``is this information consistent?'' and ``At what time(s) could I have left my home such that the above story would be true?''. 
Suppose I would have left at 8:10 and drove for 20 minutes and waited 5 minutes at the bridge, I would have arrived at work at 8:35, while I stated that I had arrived at work exactly at 8:30. 
Given the above constraints, it is not hard to discover that the only possible scenario is that I left home at 8:05 and waited only 5 minutes at the bridge.
The challenge now is to implement an algorithm that performs the same kind of reasoning.  This can be done by regarding this problem as an STP and represent it using an STN.

\subsubsection{Constraint Graph}
The first step is to represent the example above as a \emph{constraint graph}. 
The nodes in this graph correspond to the events in the story and a directed edge from node $n_i$ to $n_j$ indicates that the event represented by node $n_i$ has to occur before the event represented by node $n_j$.
These edges are called \emph{constraints}. Additionally, each edge $(n_i, n_j)$ has got a certain \emph{time window} associated with it, which indicates the minimum and maximum delay between the two events represented by time points $n_i$ and $n_j$. 
Each node in this graph is called a \emph{time point}. 
An additional time point is added and refers to \emph{time zero}. This node is connected to the node that represents the activity with the latest start time.
A convenient time zero for this example is 8:00.
The constraint graph for this example is shown below. 

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
		->,
		>=stealth',
		shorten >=1pt,
		auto,
		node distance=3cm,
	     semithick
	  ]
	
	  \node[state] (1) 						{0};
	  \node[state] (2) [right of=1] 		{L};
	  \node[state] (3) [right of=2] 		{B};
	  \node[state] (4) [right of=3] 		{A};
	
	  \path 	 (1) 	edge [bend left]    	node {[5,10]} 		(2)
	            		edge [bend right] 		node {[30,30]} 	(4)
	       	 (2) 	edge [bend left]		node {[20,20]} 	(3)
	        	 (3) 	edge [bend left]     	node {[5,10]} 		(4);
	        
	\end{tikzpicture}
	\caption{A constraint graph for Example \ref{exmp:stn}. In this example, the time zero node is called \emph{0}, and the events \emph{leaving home},  \emph{waiting at the bridge} and \emph{arrived at work} are denoted with nodes \emph{L}, \emph{B} and \emph{A} respectively.}
\end{figure}

The goal of this graph is to tighten the bounds of the time window for each time point, in such a way that if each time point is associated with a value that lies within its time window, the schedule is consistent. 
This can be done using a distance graph and applying the all-paths-closest-pairs algorithm, which we will introduce later.

\subsubsection{Distance Graph}
The distance is a graph representation of the constraint graph in which the semantics of the nodes remain the same, but all the edges have one value as the weight instead of a range of values. In order to reduce the STN to a distance matrix, the edges need to be given a fixed value, instead of a range of a values (as is the case with an STN). 
In order to do so, all edges $e_i$ in the constraint graph are given the weight of the upper bound of the associated time window. 
Additionally, for each edge in the constraint graph, an additional edge is added in opposite direction with a weight equal to the negative lower bound of the time window associated with that edge. 
Each edge now has one value as the weight instead of a range of values. 

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
		->,
		>=stealth',
		shorten >=1pt,
		auto,
		node distance=3cm,
	     semithick
	  ]
	
	  \node[state] (1) 						{0};
	  \node[state] (2) [right of=1] 		{L};
	  \node[state] (3) [right of=2] 		{B};
	  \node[state] (4) [right of=3] 		{A};
	
	  \path 	 (1) 	edge [bend left]    	node {10}	 		(2)
	            		edge [bend right] 		node {30}		 	(4)
	       	 (2) 	edge [bend left]		node {20}		 	(3)
		 			edge [bend left]    	node {-5} 			(1)
	        	 (3) 	edge [bend left]     	node {10}	 		(4)
		 			edge [bend left]		node {-20}	 		(2)
		 	 (4)		edge [bend right] 		node {-30} 		(1)
			 		edge [bend left]     	node {-5} 			(3);
	        
	\end{tikzpicture}
	\caption{A distance graph for Example \ref{exmp:stn}, with edges that have only one value as weight.}
\end{figure}

\subsubsection{Distance Matrix}
From the distance graph, a \emph{Distance Matrix} $D$ can be deduced. A distance matrix can be viewed as a numerical notation of a directed graph. In this $n$ by $n$ matrix, where $n$ is the number of nodes in the original graph, the value at position $D_{i,j}$, where $i$ and $j$ denote the row and the column number respectively, is the weight of the edge from the node represented by $i$ to the node represented by $j$. 

The distance graph can be formatted as a distance matrix $D$ by filling a cell $D_{i,j}$ either with the weight of the edge if there is an edge from the node represented by row $i$ to the the node represented by row $j$ or $\infty$ if there is no edge from the node represented by row $i$ to the the node represented by row $j$.

\begin{figure}[h]
	\centering
	\begin{tabular}{ c | c c c c }
	  			& \textbf{0}	& \textbf{L} 	& \textbf{B} 	& \textbf{A} \\ \hline
	  \textbf{0} 	& 0 			& 10		& $\infty$ 	& 30 \\
	  \textbf{L} 	& -5 		& 0			& 20		& $\infty$ \\
	  \textbf{B} 	& $\infty$ 	& -20		& 0			& 10 \\
	  \textbf{A} 	& -30		& $\infty$	& -5 		& 0 \\
	\end{tabular}
	\caption{The distance matrix for example \ref{exmp:stn}}
	\label{fig:distance_matrix}
\end{figure}

\subsubsection{Tightening the weights}
The distance matrix is a 

The distance matrix representation
Floyd-Warshall

\begin{figure}[h]
	\centering
	\begin{tabular}{ c | c c c c }
	  			& \textbf{0}		& \textbf{L} 		& \textbf{B} 		& \textbf{A} \\ \hline
	  \textbf{0} 	& 0 				& \textbf{5}		& \textbf{25} 	& 30 \\
	  \textbf{L} 	& -5 			& 0				& 20			& \textbf{25} \\
	  \textbf{B} 	& \textbf{-25}	& -20			& 0				& \textbf{5} \\
	  \textbf{A} 	& -30			& \textbf{-25}	& -5 			& 0 \\
	\end{tabular}
	\caption{The distance matrix after applying the Floyd-Warshall algorithm on Figure \ref{fig:distance_matrix}}
\end{figure}

\subsubsection{Reduction to STN}
The notion of an STN as introduced in the previous paragraph can be used to represent the temporal (time related) aspect of the original RCPSP. Let us explain the reduction of the temporal (time-related) aspect of the problem to an STN according to \TODO{Example}.

The first step of the reduction is taking an empty STN and adding two time points $s_i$ and $e_i$ for each activity $v_i$. 
These time points are then connected with a directed edge from $s_i$ to $e_i$ with time window $[\dur{i}, \dur{i}]$. 
Nodes $s_i$ and $e_i$ can be seen as the start node and end node of activity $v_i$ respectively and the time window associated with the edge that connects these two nodes forces the time between the two time points to be exactly the duration of the activity $v_i$.

Now that the activities are simulated in an STN, it is time to also incorporate the precedence constraints into the STN. This can be quite easily done if one thinks of a RCPSP precedence constraint as being an STN constraint with interval $[0,\infty]$. This means that if two time points $t_i$ and $t_j$ are connected by such an edge, it does not matter how large the interval between the two activities is, as long as it is some positive number. This will simulate the concept of a precedence constraint in an STN.

Using the method outlined in this section we are able to describe Example \ref{exmp:running} as an STN.


\begin{figure}[h]
	\makebox[\textwidth]{
		\centering
		\begin{tikzpicture}[
			->,
			>=stealth',
			shorten >=1pt,
			auto,
			node distance=2.4cm,
			scale=0.8, 
			every node/.style={transform shape},
		     semithick
		  ]
		  \label{fig:reduced-stn}
		
		  \node[state] (s0) [thick] 	 						{$s_0$};
		  \node[state] (e0) [thick] 	[right of=s0]			{$e_0$};
		  \node[state] (s1) [thick] 	[above right of=e0]	{$s_1$};
		  \node[state] (e1) [thick] 	[right of=s1]			{$e_1$};
		  \node[state] (s2) [thick] 	[right of=e0]			{$s_2$};
		  \node[state] (e2) [thick] 	[right of=s2]			{$e_2$};
		  
		  \node[state] (s3) 	[thick] 	[right of=e1]			{$s_3$};
		  \node[state] (e3) 	[thick] 	[right of=s3]			{$e_3$};
		  \node[state] (s4) 	[thick] 	[right of=e2]			{$s_4$};
		  \node[state] (e4)	[thick] 	[right of=s4]			{$e_4$};
		  \node[state] (s5) 	[thick]	[below right of=e0]	{$s_5$};
		  \node[state] (e5)	[thick]	[right of=s5]			{$e_5$};
		  \node[state] (s6)	[thick] 	[right of=e4]			{$s_6$};
		  \node[state] (e6) 	[thick] 	[right of=s6]			{$e_6$};
		  \node[state] (s7) 	[thick] 	[right of=e6]			{$s_7$};
		  \node[state] (e7) 	[thick] 	[right of=s7]			{$e_7$};
		     
		  \path 		     	(s0) 		edge [thick] node 		{$[0,0]$} 	(e0)
		  		     		(s1) 		edge [thick] node 		{$[3,3]$} 	(e1)
		  		     		(s2) 		edge [thick] node 		{$[2,2]$} 	(e2)
		  		    		(s3) 		edge [thick] node 		{$[2,2]$} 	(e3)
		  		     		(s4) 		edge [thick] node 		{$[1,1]$} 	(e4)
		  		     		(s5) 		edge [thick] node 		{$[5,5]$} 	(e5)
		  		     		(s6) 		edge [thick] node 		{$[1,1]$} 	(e6)
		  		     		(s7) 		edge [thick] node 		{$[0,0]$} 	(e7)
						
						(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s1)
		  				(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s2)
						(e0) 		edge [dashed] node 		{$[0, \infty]$} 			(s5)
						(e1) 		edge [dashed] node 		{$[0, \infty]$} 			(s3)
						(e2) 		edge [dashed] node 		{$[0, \infty]$} 			(s4)
						(e3) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e4) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e5) 		edge [dashed] node 		{$[0, \infty]$} 			(s6)
						(e6) 		edge [dashed] node 		{$[0, \infty]$} 			(s7);		\end{tikzpicture}
	}
	\caption{In this figure, the temporal aspect of the running example is reduced to an STN. Each pair of nodes $(s_i, e_i)$ represents the start and end time of an activity $v_i$. The dotted edges represent precedence constraints and the solid edges emulate activity durations.}
\end{figure}

\TODO{
		-Het is dus geen goeie/volledige reductie
		-Algemene/formele reductie Reductiedefinitie
	}

\subsection{Precedence Constraint Posting}
\label{text:PCP}
As seen in the previous section, solving an STP provides us with a time-feasable schedule. 
This schedule does not take in consideration the resources that are used and it is possible that resources are overused (as is the case in \emph{Schedule A} in Figure \ref{fig:resource_graph}). 
In order to make the time-feasable solution also comply with the resource capacity, a method called \emph{Precendence Constraint Posting} (PCP) is used. 

\subsubsection{Minimizing the Makespan}
The STN as constructed in the previous section assigns bounds to the time points in such a way that if a value $\delta$ were the be assigned to each time point $t_i$ such that $\delta \in [lb(t_i), ub(t_i)]$, all constraints in the original STP are satisfied.
Since a solution assigns actual values (instead of bounds) to each time point, in order to obtain a solution, a value needs to be given to each time point $t_i$ in the STN.

According to the definition of the problem, we would like to minimize the makespan of a project. The schedule in the STN that has the shortest makespan is the schedule that is created by assigning the lower bound of the time window of each time point and use that as a value. This ensures that each time point occurs as soon as possible, without violating the constraints in the STP. This means that all activities occur as soon as possible, without violating the precedence constraints in the problem definition. The schedule for the running example will look as follows:
\TODO{Insert ESTA time-feasable solution here}

\subsubsection{Contention Peak Detection}
Now that we have got a time-feasable schedule for the running example, it is time to look at the resource usage. 


Hoe detect je een contention peak
Pairwise Selection
MCS

\subsubsection{Conflict Extraction}
Hoe haal je de twee activiteiten die een conflict vorm uit die set

\subsubsection{Conflict Resolution}
En hoe leg je de constraint aan?


\TODO{
	-Temporal lower bound for each activity can be computed via the shortest path algorithm
		-Uitleggen huidige STN niet werkt (alleen temporal en niet resource feasable)
		-Globale idee van resource leveling using PCP
		-Algoritmw voor resource leveling (volgens ESTA en aan de hand van example)
		-Algemeen en Formeel algoritme
		}

\subsection{Final Schedule}

\TODO{
		-Hoe maak je van dat STN weer een schedule
		-Hoe voldoet het schedule (aan alle constraints)
}

\subsection{Algorithm}

\newpage

\TODO{
 - Continuous planning aanstippen in future work \\
 - Bronvermeldingen moeten er echt in, probeer het te doen terwijl je schrijft \\
 - PCP Mag iets duidelijker naar voren komen in hoofdstuk 'schedule construction' 3.2 wordt dus PCP \\
 - Goeie presentatie ;D! \\
 - Laat ergens weten dat we ervanuit gaan dat we de makespan willen minimaliseren en dat daardoor het een logische aanpak lijkt om uit te gaan van een basis schedule geconstrueerd door de earliest start time techniek. \\
 }

\newpage
 
\section{Conclusion}

We have seen that the resource constraint project scheduling problem is a common problem in everyday applications.
These applications often operate in dynamic environments, which pose many external constraints on the schedules.
The common usage of the problem in dynamic environment requires a smart approach to the problem, especially with limited resources and time.
To cope with these constraints and problems, some techniques are applied to provide with a more flexible and robust schedule.
Flexibility is key in providing a schedule that can function in a dynamic environment, handling the uncertainties which may occur.

We first explored the resource constraint scheduling problem and its applications.
This gave an insight in the problems that one can encounter in practical applications, as well as the complexity of the problem itself.
Due to the complexity of the problem it is not possible to quickly give an optimal solution for a schedule.
Because in the practical applications a quicker solving of the problem is required to keep up with the pace of the schedule execution, approximations are needed.

The approximation we discussed used simple temporal networks to represent the resources, activities and constraints given by the original problem.
The simple temporal problem can be solved more easily than the resource constraint project scheduling problem, but remains an approximation.
This means that the problem will not likely give an optimal solution and might possibly be unable to find a solution, although the original problem was feasible.

Combining this more simple representation or approximation of the problem with the precedence constraint posting method allows for the creation of a flexible and robust schedule.
In this manner the schedule can easily be adopted to changes in the environment.
In a dynamic or continuous application these changes occur quite often and must be dealt with in minimal time.

The simple temporal network and precedence constraint posting solutions offer a way of quick and effective scheduling in more complex, dynamic applications.
The paper has shown how these techniques can be used to give an effective approximation of the resource constraint project scheduling problem.
Although the results may not be optimal or sometimes might not even be found by this approximation, the quick results makes it an eligible solution for these application.

\newpage
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
